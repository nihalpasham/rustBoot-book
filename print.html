<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rustBoot Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Objectives</li><li class="chapter-item expanded "><a href="objectives.html"><strong aria-hidden="true">1.</strong> Goals</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li class="chapter-item expanded affix "><li class="part-title">Design and Architecture Overview</li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/core_components.html"><strong aria-hidden="true">3.1.</strong> Components of rustBoot</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arch/images.html"><strong aria-hidden="true">4.1.</strong> rustBoot Images</a></li><li class="chapter-item expanded "><a href="arch/partitions.html"><strong aria-hidden="true">4.2.</strong> rustBoot Partitions</a></li><li class="chapter-item expanded "><a href="arch/secure_boot_update.html"><strong aria-hidden="true">4.3.</strong> Secure-Boot & Update</a></li><li class="chapter-item expanded "><a href="arch/signing_utilities.html"><strong aria-hidden="true">4.4.</strong> Signing Utilities</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="user_guide.html"><strong aria-hidden="true">5.</strong> Build & Flash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/nrf52840.html"><strong aria-hidden="true">5.1.</strong> nrf52840</a></li><li class="chapter-item expanded "><a href="usage/rp2040.html"><strong aria-hidden="true">5.2.</strong> rp2040</a></li><li class="chapter-item expanded "><a href="usage/rpi4.html"><strong aria-hidden="true">5.3.</strong> rpi4</a></li><li class="chapter-item expanded "><a href="usage/stm32f411.html"><strong aria-hidden="true">5.4.</strong> stm32f411</a></li><li class="chapter-item expanded "><a href="usage/stm32f446.html"><strong aria-hidden="true">5.5.</strong> stm32f446</a></li><li class="chapter-item expanded "><a href="usage/stm32h723.html"><strong aria-hidden="true">5.6.</strong> stm32h723</a></li><li class="chapter-item expanded "><a href="usage/stm32f746.html"><strong aria-hidden="true">5.7.</strong> stm32f746</a></li><li class="chapter-item expanded "><a href="usage/stm32f334.html"><strong aria-hidden="true">5.8.</strong> stm32f334</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Coding Guidelines and Testing</li><li class="chapter-item expanded "><a href="coding_guide.html"><strong aria-hidden="true">6.</strong> Coding guidelines</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">7.</strong> Testing</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuous Integration</li><li class="chapter-item expanded "><a href="continuous-integration.html"><strong aria-hidden="true">8.</strong> Continuous Integration</a></li><li class="chapter-item expanded affix "><li class="part-title">For Developers</li><li class="chapter-item expanded "><a href="for_developers/index.html"><strong aria-hidden="true">9.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for_developers/ref_guide.html"><strong aria-hidden="true">9.1.</strong> Reference Guide</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rustBoot Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/nihalpasham/rustBoot-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rustboot"><a class="header" href="#rustboot"><code>rustBoot</code></a></h1>
<p><em>by Nihal Pasham</em> </p>
<p>rustBoot is a standalone bootloader, written entirely in <code>Rust</code>, designed to run on anything from a microcontroller to a system on chip. It can be used to boot into bare-metal firmware or Linux.</p>
<h2 id="why-rustboot"><a class="header" href="#why-rustboot">Why rustBoot?</a></h2>
<p>rustBoot prioritizes the following above all else.</p>
<ul>
<li>keep only the bare-essentials</li>
<li>secure by default</li>
<li>low-integration complexity</li>
</ul>
<p><code>rustBoot</code> does the bare minimum needed to securely boot bare-metal firmware (or Linux) i.e. it has a really small <code>trusted computing base</code>. It is secure by default i.e. it <code>does not boot digitally unsigned firmware</code> and uses <code>memory-safe implementations</code> (for crypto and boot-logic) as the default. It also attempts to eliminate the high degree of integration-complexity involved in rolling a production-grade bootloader by adopting a <code>batteries-included</code> approach. </p>
<ul>
<li><em>For example, we include <code>flash device drivers for all supported boards</code>, written in safe Rust.</em></li>
</ul>
<h2 id="why-prioritize-the-above"><a class="header" href="#why-prioritize-the-above">Why prioritize the above?</a></h2>
<h3 id="trusted-computing-base"><a class="header" href="#trusted-computing-base">Trusted Computing Base:</a></h3>
<p>Open-source bootloaders have a large trusted computing base i.e. they (pretty much) resemble a mini operating system with </p>
<ul>
<li>a complete networking stack</li>
<li>a collection of device drivers and device-tree blob(s)</li>
<li>integrated debug and command shells</li>
<li>support for every possible filesystem you can think of.   </li>
<li>and more stuff.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> This includes <a href="https://github.com/u-boot/u-boot"><code>U-boot</code></a>, the de-facto standard in the embedded-systems world. <a href="https://github.com/nccgroup/depthcharge"><code>DepthCharge</code></a> is an example of a U-Boot hacking toolkit for security researchers and tinkerers, designed to exploit U-boot's large attack surface. </p>
</blockquote>
<p><a href="https://raw.githubusercontent.com/imrank03/rustBoot-book-diagrams/main/Mental_map.svg?raw=true"><img src="https://raw.githubusercontent.com/imrank03/rustBoot-book-diagrams/main/Mental_map.svg?raw=true" alt="mental_map_uboot_attack_surface" title="Mental map of U-boot attack surface" /></a></p>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory safety:</a></h3>
<p>A large TCB inevitably equates to a large attack surface. The vast majority of them are written in C or some combination of C and Assembly. <code>A quick analysis of CVEs</code> reported over the last 2 years (in u-boot, bare-box and other open-source ones) show that the bulk of them fall into the memory-safety category. </p>
<blockquote>
<p><strong>Note:</strong> <code>addressable attack surface</code> is much larger, the above <code>attack surface</code> is only compounded when we add boot-time driver vulnerabilities.</p>
</blockquote>
<h3 id="complexity--boot-time"><a class="header" href="#complexity--boot-time">Complexity &amp; boot-time:</a></h3>
<p>Custom secure boot implementations can <code>get quite complex and add latency</code> with </p>
<ul>
<li>redundant hierarchical digital signature verification trust chains or </li>
<li>elaborate parsing of custom header or container formats.</li>
</ul>
<h3 id="vendor-dependencies"><a class="header" href="#vendor-dependencies">Vendor dependencies:</a></h3>
<p>Vendor-specific or custom chain of trust dependencies make it difficult to port bootloader implementations across boards.  This is in-part attributable to <code>non-standards based solutions</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<p>Contrary to prevailing wisdom, writing your own secure-bootloader is a complex project. The effort involved in developing/integrating one can be overwhelming. For example, we'll need to address a plethora of accompanying tasks such as key-management, signing infrastructure, code-safety, trust-chains, reliable back-ups etc. before we even get to the <code>actual booting logic</code>. </p>
<p>rustBoot's purpose is to help simplify the entire process. Its primary goals are</p>
<ul>
<li><strong>complies with key requirements of the <a href="https://datatracker.ietf.org/wg/suit/about/">IETF-SUIT</a> standard</strong> i.e.
<ul>
<li>one of <code>SUIT's requirements</code> - transferring or downloading an <code>update</code> should be delegated to the firmware/OS to avoid <code>size or computational</code> limitations. In other words, the bootloader should NOT be required to download and install an update. This removes the need for a networking stack and provides for a drastic reduction in the bootloader's attack surface.</li>
<li>SUIT also does not mandate the use of specific protocols or data link interfaces to transfer <code>updates</code> to a device. </li>
<li>rustBoot fully complies with this requirement. </li>
</ul>
</li>
<li><strong>reliable updates:</strong>
<ul>
<li>reliable updates in rustBoot will take the form of
<ul>
<li><code>flash swap operations</code> for microcontroller based systems. We'll use the <code>boot/update based multi-slot partitioning method</code> to replace currently active firmware with a newly received update and at the same time store a back-up copy of it in a (passive) secondary partition.</li>
<li><code>ram swap operations</code> for more powerful system-on-chip boards which can boot Linux. </li>
</ul>
</li>
</ul>
</li>
<li><strong>predictability over performance:</strong> 
<ul>
<li>one of rustBoot's core design objectives is to keep it simple and avoid complexity. So, there will be little to no application of meta or async programming constructs. </li>
</ul>
<blockquote>
<p><strong>Note:</strong> We don't actually need the extra performance. rustBoot can hit sub-second <code>secure boot-times</code> as we've stripped it down to the bare-essentials. This assumes flash load times are fast enough and a firmware binary-blob size of &lt; 1MB.</p>
</blockquote>
</li>
<li><strong>zero-dynamic memory allocation:</strong>
<ul>
<li>to make it highly portable, apart from its modular design, rustBoot relies on a zero dynamic memory allocation architecture i.e. no heap required. </li>
</ul>
</li>
<li><strong>memory safety &amp; type-state programming:</strong> 
<ul>
<li>the entire bootloader is written in rust's safe-fragment with a limited set of well-defined api(s) for unsafe HW access.</li>
<li>as a consequence, it makes rustBoot immune to a whole host of memory safety bugs. ex: things like parsing image-headers (i.e. container-formats) in rustBoot is much safer.</li>
<li>rustBoot takes advantage of rust's powerful type-system to make <code>invalid boot-states, unrepresentable at compile time</code> and along with constructs such as sealed states, global singletons, it improves the overall security of the entire code-base.</li>
</ul>
</li>
</ul>
<blockquote>
<p>There is a plan to further add to rustBoot's high levels of assurance by leveraging <code>formal methods</code> such as</p>
<ul>
<li><code>property-based testing via symbolic execution:</code> to formally verify rustBoot's parser.</li>
<li><code>deductive verification:</code> for critical sections of code (ex: swapping contents of boot and update partitions).</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="features-currently-supported"><a class="header" href="#features-currently-supported">Features currently supported:</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
support for <code>ARM Cortex-M, Cortex-A</code> micro-architectures</li>
<li><input disabled="" type="checkbox" checked=""/>
support for multi-slot partitioning of microcontroller flash memory. This allows us to implement the <code>boot/update</code> approach for bare-metal <code>firmware updates</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
support for <code>Aarch64 linux</code> booting</li>
<li><input disabled="" type="checkbox" checked=""/>
elliptic curve cryptography for integrity and authenticity verification using <a href="https://github.com/RustCrypto"><code>RustCrypto</code></a> crates</li>
<li><input disabled="" type="checkbox" checked=""/>
a tiny hardware abstraction layer for non-volatile memory (i.e. flash) access.</li>
<li><input disabled="" type="checkbox" checked=""/>
anti-rollback protection via version numbering.</li>
<li><input disabled="" type="checkbox" checked=""/>
a fully memory safe core-bootloader implementation with safe parsers and firmware-update logic.</li>
<li><input disabled="" type="checkbox" checked=""/>
power-interruptible firmware updates along with the assurance of fall-back availability.</li>
</ul>
<h2 id="features-planned"><a class="header" href="#features-planned">Features planned:</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
switch to <code>rust-based signing tools</code> for manifest-header creation, key-generation and firmware signing to improve scalability and security (currently examples use a python implementation for this). </li>
<li><input disabled="" type="checkbox"/>
support for external flash devices (ex: SPI flash) and serial/console logging interfaces.</li>
<li><input disabled="" type="checkbox"/>
support for <code>ARM TrustZone-M and A</code> and certified <code>secure hardware elements</code> - microchip ATECC608a, NXP SE050, STSAFE-100</li>
<li><input disabled="" type="checkbox"/>
support for a highly secure and efficient <code>firmware transport</code> method over end-end mutually authenticated and encrypted channels via <a href="https://github.com/ockam-network/ockam/tree/develop/documentation/use-cases/end-to-end-encryption-with-rust#readme">ockam-networking-libraries</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p><code>rustBoot</code> aims to offer an OS and micro-architecture agnostic (i.e. highly portable) standards-based secure bootloader that's easy to integrate into existing embedded software projects. Its architecture is designed around a simple idea – <code>a bootloader handles ONLY the bare-essentials and offloads the rest to systems that are better suited for the job.</code> </p>
<h2 id="what-does-a-bootloader-actually-do"><a class="header" href="#what-does-a-bootloader-actually-do">What does a bootloader actually do?</a></h2>
<ol>
<li>it initializes (the bare-minimum) requisite hardware. Ex: cpu-core, flash, gpios, uart, (RAM and hardware secure elements if needed).</li>
<li>digitally verifies or authenticates firmware.</li>
<li>boots or passes control over to firmware or an OS i.e. <code>linux or RTOS or bare-metal</code> and</li>
<li>if an update is available, it validates and applies the update before performing a re-boot. </li>
</ol>
<p>In this chapter, we'll talk about rustBoot's design and its core components.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="components-of-rustboot"><a class="header" href="#components-of-rustboot">Components of rustBoot</a></h2>
<p>At its core, <code>rustBoot</code> is comprised of 4 components</p>
<ul>
<li>the core bootloader</li>
<li>a minimal hardware abstraction layer</li>
<li>fast and safe crypto drivers</li>
<li>rustBoot firmware interface</li>
</ul>
<h3 id="the-core-bootloader"><a class="header" href="#the-core-bootloader">The core bootloader</a></h3>
<ul>
<li>has a tiny trusted computing base i.e. its less than <code>32KB in size</code> when compiled to an executable.</li>
<li>this includes signature-based authentication, reliable firmware updates with rollbacks and protections against downgrades attacks.</li>
</ul>
<h3 id="a-minimal-hardware-abstraction-layer"><a class="header" href="#a-minimal-hardware-abstraction-layer">A minimal hardware abstraction layer</a></h3>
<p>rustBoot provides abstractions for the following hardware classes i.e. it exposes a tiny API for you to easily integrate the following types of hardware.</p>
<ul>
<li>flash memory controllers: NVMC, SPI-flash, EMMC block devices etc.</li>
<li>TrustZone: Cortex-M or Cortex-A </li>
<li>serial interfaces: UART(s), GPIO(s)</li>
</ul>
<blockquote>
<p><strong>Note:</strong> To minimize integrational complexity and enhance security, we already provide a number of different hardware drivers written in safe-rust. So, you can use <code>your own drivers using rust-ffi</code> or use existing ones from the repo.</p>
</blockquote>
<h3 id="fast-and-safe-crypto-drivers"><a class="header" href="#fast-and-safe-crypto-drivers">Fast and safe crypto drivers</a></h3>
<ul>
<li><code>hardware secure elements or accelerators:</code> again, rustBoot offers drivers for crypto hardware or you can use your own.
<ul>
<li>examples of supported vendor-specific crypto modules include <code>ATECC608a</code>.</li>
</ul>
</li>
<li><code>software implementations of crypto-libraries:</code> rustBoot uses the <code>RustCrypto</code> project as its software crypto provider. 
<ul>
<li>This includes all crates in the rustcrypto project - hashing, signing, verification, encryption etc.</li>
</ul>
</li>
</ul>
<h3 id="rustboot-firmware-interface"><a class="header" href="#rustboot-firmware-interface">rustBoot firmware interface</a></h3>
<ul>
<li>rustBoot complies with a key requirement of the <a href="https://datatracker.ietf.org/wg/suit/about/"><strong>IETF-SUIT</strong></a> standard and does not include a networking stack, instead networking is offloaded to the underlying firmware/OS. </li>
<li>Firmware updates are downloaded and stored in non-volatile storage.</li>
<li>In order to trigger the update, rustBoot provides a simple API that can be called from within bare-metal firmware or linux.</li>
</ul>
<blockquote>
<p>Note: In the above context, firmware refers to either linux or bare-metal firmware. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-overview"><a class="header" href="#high-level-overview">High Level Overview</a></h1>
<p>rustBoot's architecture reflects its focus on <code>simplicity and security</code>, above everything else. </p>
<p>For a high-level overview, you can think of rustBoot as operating in 2 independent stages. </p>
<ul>
<li><strong>Pre-handover stage:</strong> post power-on, the BootROM (or some other intermediate-stage bootloader) executes and hands control over to <code>rustBoot</code>. This is a stage where <code>rustBoot</code> has full <code>execution control</code>.</li>
<li><strong>Post-handover stage:</strong> firmware has begun executing and has complete <code>execution control</code>. Firmware uses a couple <code>rustBoot</code> dependencies to trigger and confirm updates.</li>
</ul>
<h2 id="pre-handover-stage"><a class="header" href="#pre-handover-stage">Pre-handover stage:</a></h2>
<ul>
<li>rustBoot provides a minimal hardware abstraction layer for a wide range of ARM microcontrollers (STM32, Nordic, Microchip etc.) and microprocessors (rpi4, NXP etc.). The HAL allows peripherals drivers to initialize requisite hardware such as flash memories, UART controllers, GPIO pins etc.</li>
<li>an optional software-based crypto library in-case you don't need (or use) dedicated crypto hardware.</li>
<li>rustBoot's core-bootloader houses all of the <code>actual boot-logic</code> such as
<ul>
<li>firmware image <code>integrity and authenticity verification</code> via digital signatures</li>
<li>power-interruptible firmware updates along with the assurance of fall-back availability. </li>
<li><code>FIT-Image and device tree</code> parsing while booting linux.</li>
<li>multi-slot partitioning of microcontroller flash memory</li>
<li><code>anti-rollback protection</code> via version numbering.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/pre_handover_stage.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/pre_handover_stage.svg?raw=true" alt="pre_handover_stage" title="Simplified Block Diagram, Pre handover stage:" /></a></p>
<h2 id="post-handover-stage"><a class="header" href="#post-handover-stage">Post-handover stage:</a></h2>
<ul>
<li>At this stage, control has been handed over to firmware (or linux).</li>
<li>rustBoot <code>does not</code> have a networking stack. The job of downloading and installing an update is offloaded to firmware or linux (<a href="index.html#trusted-computing-base"><code>drastically reducing the TCB</code></a>)</li>
<li>Firmware can trigger and confirm updates by setting the state of the <code>update</code> partition via a rustBoot api. This removes the need for a filesystem (<a href="index.html#trusted-computing-base"><code>again smaller TCB</code></a>). 
<ul>
<li>However, not all systems can boot without a file-system. </li>
<li>If you need one, rustBoot offers a FAT 16/32 implementation, written in safe rust. </li>
</ul>
</li>
<li>Once an update is triggered, the device is reset (i.e. restarted). rustBoot takes over and attempts to verify the update. If everything checks out, it boots the updated firmware.</li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/post_handover_stage.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/post_handover_stage.svg?raw=true" alt="post_handover_stage" title="Simplified Block Diagram, Post handover stage:" /></a></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>rustBoot <code>can replace U-boot</code> in a trust-chain i.e. it can easily be integrated into an existing trust-chain, wherever U-boot is used.</li>
<li>As it has a very small hardware abstraction layer, it is highly portable across Cortex-M and Cortex-A architectures. </li>
<li>Public-key hashes or trust anchors can be stored in secure hardware or embedded in software.</li>
<li>Hardware drivers for different types of secure-hardware (ex: crypto elements) will be made available via the HAL. </li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustboot-images"><a class="header" href="#rustboot-images">rustBoot Images</a></h1>
<p>rustBoot supports 2 types of firmware image formats, depending on the underlying device. It could either be an</p>
<ul>
<li><a href="arch/./images.html#mcu-image-format"><code>mcu-image:</code></a> a simple 256-byte firmware image format for microcontrollers or a</li>
<li><a href="arch/./images.html#fit-image-format"><code>fit-image:</code></a> the flattened-image-tree format for systems capable of booting linux.</li>
</ul>
<h2 id="mcu-image-format"><a class="header" href="#mcu-image-format">MCU image format</a></h2>
<p>rustBoot mcu-images comprise of a <code>256-byte header</code> pre-pended to a firmware binary and are deliberately designed to be as simple as possible. </p>
<ul>
<li>it does not rely on the use of complex digital certificate formats which keeps the <a href="arch/../index.html#trusted-computing-base"><code>TCB</code></a> small and avoids unnecessary <a href="arch/../index.html#complexity--boot-time">code-complexity</a></li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/rustBoot_header.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/rustBoot_header.svg?raw=true" alt="rustBoot_header" title="Simplified Block Diagram, 256 byte rustBoot header" /></a></p>
<h3 id="rustboot-image-header-layout"><a class="header" href="#rustboot-image-header-layout">rustBoot image header layout:</a></h3>
<p>The header always starts with a 4-byte magic number, followed by a 4-byte field indicating the size of the firmware image (excluding the header). All header contents are stored in little-endian format.</p>
<p>The 2 (<code>magic and size</code>) fixed fields are followed by one or more <code>TLV(s) or Type, Length, Value</code> tags. A TLV has the following layout</p>
<ul>
<li><strong>Type:</strong> 2 bytes to indicate the <code>Type</code> of the tag</li>
<li><strong>Length:</strong> 2 bytes to indicate the <code>length in bytes</code> of the tag (excluding the type and size bytes).</li>
<li><strong>Value:</strong> N bytes of tag content</li>
</ul>
<h3 id="padding-and-end-of-header-bytes"><a class="header" href="#padding-and-end-of-header-bytes">Padding and End of header bytes:</a></h3>
<ul>
<li>An <code>0xFF</code> byte in the <code>Type</code> field indicates a padding byte. A 'padding' byte does <em>NOT</em> have a size field, and the next byte is interpreted as <code>Type</code> again.</li>
<li>A 2 byte value of <code>0x0000</code> signals the end of the rustBoot header. </li>
</ul>
<h3 id="tags"><a class="header" href="#tags">Tags:</a></h3>
<p>Each tag represents some information about the firmware. <code>rustBoot</code> requires the following <code>Tags</code> for firmware validation:</p>
<ul>
<li>The <code>version</code> tag provides firmware version number information.
<ul>
<li>Type: <code>0x0001</code></li>
<li>Length: 4 bytes</li>
</ul>
</li>
<li>The <code>timestamp</code> tag provides the timestamp in unix seconds for when the <code>rustBoot image</code> was created.
<ul>
<li>Type: <code>0x0002</code></li>
<li>Length: 8 bytes</li>
</ul>
</li>
<li>The <code>auth type</code> tag identifies the type of the authentication mechanism in use. Ex: which ECC curve are we using and what's the key strength etc.
<ul>
<li>Type: <code>0x0030</code></li>
<li>Length: 2 bytes</li>
</ul>
</li>
<li>The <code>sha256 digest</code> tag contains a <code>SHA2 hash</code> of the firmware and is used to check firmware integrity.
<ul>
<li>Type: <code>0x0003</code></li>
<li>Length: <code>32 bytes</code></li>
</ul>
</li>
<li>The <code>firmware signature</code> tag contains the <code>ECC signature</code> and is used to verify firmware against a known public key.
<ul>
<li>Type: <code>0x0020</code></li>
<li>Length: 64 bytes</li>
</ul>
</li>
</ul>
<h3 id="optional-tags"><a class="header" href="#optional-tags">Optional tags:</a></h3>
<ul>
<li><strong>Pubkey Hint:</strong> A <code>pubkey hint digest</code> tag can be included in the header.
<ul>
<li>Type: <code>0x1000</code></li>
<li>Length: 32 bytes</li>
<li>This tag contains the SHA256 digest of the public key of the corresponding private-key used by the signing tool. The bootloader may use this field to locate the correct public key in case multiple keys are available.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>MCU defaults:</strong> </p>
<ul>
<li>By default, a valid rustBoot image is always signed.</li>
<li>It relies on the 256-byte header for firmware validation.</li>
<li>It will fail to boot an image
<ul>
<li>if it does not possess a <a href="arch/images.html#rustboot-images"><code>valid rustBoot header</code></a> or</li>
<li>if it isn't signed or if it cannot be verified using the included the <a href="arch/images.html#tags"><code>authentication-type</code></a>.</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="fit-image-format"><a class="header" href="#fit-image-format">FIT-image format</a></h2>
<p>rustBoot leverages Uboot's <a href="https://raw.githubusercontent.com/u-boot/u-boot/master/doc/uImage.FIT/howto.txt"><code>flattened-uImage-tree</code></a> format to boot the linux kernel. </p>
<p>The FIT format is essentially an extension of  the <a href="https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.4-rc1"><code>device-tree</code></a> format. FIT allows us to combine multiple binaries such as the kernel, ramdisk, device-tree-blob etc. into a single image. </p>
<p>A typical rustBoot fit-image contains 4 items in the following order</p>
<ul>
<li>  kernel</li>
<li>  fdt</li>
<li>  initrd</li>
<li>  rbconfig</li>
</ul>
<h3 id="an-example-fit-image-source-file"><a class="header" href="#an-example-fit-image-source-file">An example fit-image source file:</a></h3>
<p>It is also referred to as an <code>image-tree</code> source file or <code>.its</code> file.</p>
<pre><code class="language-json">/dts-v1/;

/ {
        description = &quot;rustBoot FIT Image&quot;;
        #address-cells = &lt;1&gt;;

        images {
                kernel {
                        description = &quot;Kernel&quot;;
                        data = /incbin/(&quot;vmlinuz&quot;);     
                        type = &quot;kernel&quot;;
                        arch = &quot;arm64&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        load = &lt;0x40480000&gt;;
                        entry = &lt;0x40480000&gt;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                fdt {
                        description = &quot;DTB&quot;;
                        data = /incbin/(&quot;unpatched-bcm2711-rpi-4-b.dtb&quot;);
                        type = &quot;flat_dt&quot;;
                        arch = &quot;arm64&quot;;
                        compression = &quot;none&quot;;
                        load = &lt;0x43000000&gt;;
                        entry = &lt;0x43000000&gt;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                initrd {
                        description = &quot;Initrd&quot;;
                        data = /incbin/(&quot;initramfs&quot;);
                        type = &quot;ramdisk&quot;;
                        arch = &quot;arm64&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                rbconfig {
                        description = &quot;rustBoot Config&quot;;
                        data = /incbin/(&quot;rbconfig.txt&quot;);
                        type = &quot;rustBoot cmdline config&quot;;
                        arch = &quot;none&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
        };

        configurations {
                default = &quot;bootconfig&quot;;
                bootconfig {
                        description = &quot;Boot Config&quot;;
                        kernel = &quot;kernel&quot;;
                        fdt = &quot;fdt&quot;;
                        ramdisk = &quot;initrd&quot;;
                        rbconfig = &quot;rbconfig&quot;;
                        signature@1 {
				algo = &quot;sha256,ecdsa256,nistp256&quot;;
				key-name-hint = &quot;dev&quot;;
				signed-images = &quot;fdt&quot;, &quot;kernel&quot;, &quot;ramdisk&quot;, &quot;rbconfig&quot;;
                                value = &quot;&quot;;
			};
                };
        };

};
</code></pre>
<p>The default configuration of an <code>.its</code> file determines which kernel, initrd, fdt and rbconfig is to be used for booting. In the above example, <code>bootconfig</code> is our default configuration. </p>
<blockquote>
<p>rustBoot's FIT parser will select the corresponding kernel, fdt, initrd and rbconfig associated with <code>bootconfig</code> for booting</p>
</blockquote>
<h3 id="building-a-rustboot-compliant-fit-image"><a class="header" href="#building-a-rustboot-compliant-fit-image">Building a rustBoot compliant fit-image:</a></h3>
<p>As shown in the example above, a rustBoot compliant fit-image contains 4 items - </p>
<ul>
<li><code>kernel</code> - the linux kernel </li>
<li><code>fdt</code> - the flattened device tree or device tree blob</li>
<li><code>ramdisk</code>- a root filesystem that is embedded into the kernel and loaded at an early stage of the boot process. It is the successor of initrd. It can do things the kernel can't easily do by itself during the boot process. For example: customize the boot process (e.g., print a welcome message) </li>
<li><code>rbconfig</code> - this is rustBoot's kernel configuration. A simple <code>txt</code> file to add kernel command-line arguments.</li>
</ul>
<p>You can retrieve the first 3 (i.e. kernel, fdt, ramdisk) from a pre-built OS image: </p>
<ul>
<li>Maintainers of a linux distribution provide pre-built OS images. These images usually contain several partitions such as - 
<ul>
<li><code>boot:</code> contains the bootloader, kernel, dtb, ramdisk and other stuff</li>
<li><code>system:</code> contains the root file system </li>
<li><code>others:</code> may contain other partitions for things such as storage etc.</li>
</ul>
</li>
<li>simply download an OS image or a pre-built linux distribution from the maintainers website.
<ul>
<li>in this example, I'll be using the <a href="https://www.apertis.org/download/"><code>apertis</code></a> distribution.</li>
</ul>
</li>
<li>it’s usually a compressed (zImage) format, decompress it using a tool like unarchiver to get a disk image.</li>
<li>use <code>partx --show</code> to list all partitions</li>
</ul>
<pre><code class="language-powershell">$ partx --show __linux_image_filepath__
NR  START     END SECTORS SIZE NAME UUID
 1   8192  532479  524288 256M      9730496b-01
 2 532480 3661823 3129344 1.5G      9730496b-02
</code></pre>
<p>In the above case, the first partition with a size of 256MB contains the boot-files. It's usually named <code>boot</code>. We can calculate the offset to the <code>boot</code> volume/partition with the following command </p>
<pre><code class="language-powershell">$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
&gt; 8192 * 512
&gt; 4194304
&gt; quit
</code></pre>
<blockquote>
<p><code>512</code> is the sector-size. We multiply sector-size with the sector offset to get the actual starting (byte) location of <code>boot</code>.</p>
</blockquote>
<p>mount the partition as an <code>ext4</code> file-system (or <code>fat</code> file-system, whichever)</p>
<pre><code>$ sudo mkdir /mnt/other
$ sudo mount -v -o offset=4194304 -t ext4 /_path_to_file_image/__filename__.img /mnt/other
mount: /dev/loop0 mounted on /mnt/other.

Check mounted image

$ ls /mnt/other
</code></pre>
<p>Copy the <code>dtb</code>, <code>ramdisk</code> and <code>vmlinuz</code> image (i.e. kernel) from the mounted partition to a new folder. You can give it any name you want. I'll use <code>pkg</code> for this example.</p>
<blockquote>
<p>vmlinuz is a PE (portable executable) i.e. we can jump to it and it will in-turn jump to the kernel's entry point.</p>
</blockquote>
<p><code>rbconfig:</code> Lastly, create a file named <code>rbconfig.txt</code> in the pkg folder. This file will be used by rustBoot to pass command-line parameters to the linux kernel. </p>
<p>Here's an example of the <code>rbconfig.txt</code> file -</p>
<pre><code class="language-powershell">bootargs=&quot;root=UUID=64bc182a-ca9d-4aa1-8936-d2919863c22a rootwait ro plymouth.ignore-serial-consoles fsck.mode=auto fsck.repair=yes cma=128M&quot;
</code></pre>
<p>When you have added all 4 items to the <code>pkg</code> folder, you can build a fit-image by running the following commands. </p>
<p><strong>On a mac:</strong> </p>
<pre><code class="language-powershell">brew install u-boot-tools
</code></pre>
<p><strong>On a linux machine:</strong></p>
<pre><code class="language-powershell">sudo apt install u-boot-tools
</code></pre>
<p>and then run </p>
<pre><code class="language-powershell">mkimage -f rpi4-apertis.its rpi4-test-apertis.itb
</code></pre>
<blockquote>
<ul>
<li>the input to <code>mkimage</code> is an <code>.its</code> file.</li>
<li>and <code>.itb</code> filename we've specified is the name given to the generated fit-image (that's stored in the <code>pkg</code> folder). </li>
<li>you can copy the contents of the example <a href="arch/./images.html#an-example-fit-image-source-file"><code>fit-image</code></a> file above into a new <code>.its</code> file named <code>rpi4-apertis.its</code> and add it to the pkg folder.</li>
</ul>
</blockquote>
<pre><code>Output:

rpi4-apertis.its:65.37-70.6: Warning (unit_address_vs_reg): /configurations/bootconfig/signature@1: node has a unit name, but no reg or ranges property
Image contains unit addresses @, this will break signing
FIT description: rustBoot FIT Image
Created:         Sat Jun  4 13:18:45 2022
 Image 0 (kernel)
  Description:  Kernel
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Kernel Image
  Compression:  uncompressed
  Data Size:    29272576 Bytes = 28586.50 KiB = 27.92 MiB
  Architecture: AArch64
  OS:           Linux
  Load Address: 0x40480000
  Entry Point:  0x40480000
  Hash algo:    sha256
  Hash value:   97dcbff24ad0a60514e31a7a6b34a765681fea81f8dd11e4644f3ec81e1044fb
 Image 1 (fdt)
  Description:  DTB
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Flat Device Tree
  Compression:  uncompressed
  Data Size:    25713 Bytes = 25.11 KiB = 0.02 MiB
  Architecture: AArch64
  Load Address: 0x43000000
  Hash algo:    sha256
  Hash value:   3572783be74511b710ed7fca9b3131e97fd8073c620a94269a4e4ce79d331540
 Image 2 (initrd)
  Description:  Initrd
  Created:      Sat Jun  4 13:18:45 2022
  Type:         RAMDisk Image
  Compression:  uncompressed
  Data Size:    32901194 Bytes = 32130.07 KiB = 31.38 MiB
  Architecture: AArch64
  OS:           Linux
  Load Address: unavailable
  Entry Point:  unavailable
  Hash algo:    sha256
  Hash value:   f1290587e2155e3a5c2c870fa1d6e3e2252fb0dddf74992113d2ed86bc67f37c
 Image 3 (rbconfig)
  Description:  rustBoot Config
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Unknown Image
  Compression:  uncompressed
  Data Size:    141 Bytes = 0.14 KiB = 0.00 MiB
  Hash algo:    sha256
  Hash value:   b16d058c4f09abdb8da98561f3a15d06ff271c38a4655c2be11dec23567fd519
 Default Configuration: 'bootconfig'
 Configuration 0 (bootconfig)
  Description:  Boot Config
  Kernel:       kernel
  Init Ramdisk: initrd
  FDT:          fdt
  Sign algo:    sha256,ecdsa256,nistp256:dev
  Sign value:   00
  Timestamp:    unavailable
</code></pre>
<p>This <code>.itb</code> file is our fit-image. It does not contain a signature yet i.e. it is not signed - notice the <code>sign-value</code> field is empty. </p>
<h3 id="signing-fit-images"><a class="header" href="#signing-fit-images">Signing fit-images</a></h3>
<p>rustBoot fit-images are signed with <code>ecdsa256</code>. The signature includes the kernel, fdt, initrd and rbconfig. </p>
<p>Signing a rustBoot fit-image involves 2 steps: </p>
<ul>
<li><strong>Building a fit-image:</strong> As explained in <a href="arch/./images.html#building-a-rustboot-compliant-fit-image">preceding section</a>, FIT images can be built using <code>mkimage</code> - a command-line utility from the <code>uboot-tools</code> package i.e. you can pass an <code>.its</code> file to the mkimage tool and mkimage will produce an <code>.itb</code> blob or a image-tree blob.</li>
<li><strong>signing the fit-image:</strong>  once you've built your fit-image, you can pass the it along with a signing key to rustBoot's <code>rbsigner</code> utility to <a href="arch/./signing_utilities.html#signed-fit-image">generate a signed fit-image</a>. </li>
</ul>
<blockquote>
<p><strong>FIT-image defaults:</strong> </p>
<ul>
<li>By default, valid rustBoot images are always signed.</li>
<li>It will fail to boot an image
<ul>
<li>if the image fails fit-validation i.e. if its not a properly formatted fit-image or if the fit-parser cant find the specified default config or its components. </li>
<li>if it isn't signed or if it cannot be verified using the specified algo.</li>
</ul>
</li>
<li>rustBoot's fit parser currently supports the following architectures
<ul>
<li><code>Aarch64</code></li>
</ul>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustboot-partitions"><a class="header" href="#rustboot-partitions"><code>rustBoot Partitions</code></a></h1>
<p><code>rustBoot</code> has 2 distinct partitioning schemes, depending on the type of the underlying system.</p>
<ul>
<li><a href="arch/./partitions.html#micro-controller-partitions"><strong>micro-controller partitions:</strong></a> uses the concept of <a href="https://github.com/nihalpasham/rustBoot/issues/2"><code>swappable flash partitions</code></a> to update micro-controller firmware. 
<blockquote>
<p>This usually means bare-metal firmware but it is also applicable to <code>RTOS(s)</code>.</p>
</blockquote>
</li>
<li><a href="arch/./partitions.html#linux-system-partitions"><strong>linux system partitions:</strong></a> uses a single fat32 partition to host the <code>rustBoot-bootloader</code> and  (boot/update) fit-images. This method uses a <code>rustBoot-state</code> file to determine which image is to be booted.</li>
</ul>
<h2 id="micro-controller-partitions"><a class="header" href="#micro-controller-partitions">Micro-controller Partitions:</a></h2>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/partition.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/partition.svg?raw=true" alt="partition" title="Simplified Block Diagram, 256 byte rustBoot header" /></a></p>
<blockquote>
<p>Note: <code>BOOT</code>, <code>UPDATE</code> and <code>SWAP</code> partitions need <strong>NOT</strong> be consecutively laid out in flash memory. The above diagram only serves as a visual aid.</p>
</blockquote>
<p>rustBoot requires an <code>mcu's</code> non-volatile memory (or <code>flash storage</code>) to be divided into (at-least) 4 non-overlapping memory regions (i.e. partitions). </p>
<ul>
<li><code>rustBoot</code>: contains the bootloader. This usually starts at <code>address 0x0</code> in flash-memory. </li>
<li><code>BOOT:</code> contains boot firmware. <code>rustBoot</code> always boots from this partition address.</li>
<li><code>UPDATE:</code> contains update firmware i.e. downloaded update firmware is placed in this partition.</li>
<li><code>SWAP:</code> is an empty partition that is used to swap contents of <code>BOOT</code> and <code>UPDATE</code>, one sector at a time.</li>
</ul>
<p>All 3 partition boundaries must be aligned to a physical sector as <code>rustBoot</code> erases all flash sectors prior to storing a new firmware image, and swaps the contents of the two partitions, one sector at a time.</p>
<p>To ensure that a partition's sector alignments are maintained, the following points must be considered:</p>
<ul>
<li><code>BOOT and UPDATE</code> partition must be of the same size.</li>
<li><code>SWAP</code> partition <code>must be larger than or equal to the largest sector</code> in either <code>BOOT</code> or <code>UPDATE</code> partition.</li>
</ul>
<p>MCU flash memory is partitioned as follows:</p>
<ul>
<li>rustBoot partition starts at <code>address 0x0</code> in flash memory. It should be at least 32KB in size.</li>
<li><code>BOOT</code> partition starts at a pre-defined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L8"><code>BOOT_PARTITION_ADDRESS</code></a></li>
<li><code>UPDATE</code> partition starts at a pre-defined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L10"><code>UPDATE_PARTITION_ADDRESS</code></a>
<ul>
<li>both partitions must be of the same size, defined by <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L6"><code>PARTITION_SIZE</code></a></li>
</ul>
</li>
<li><code>SWAP</code> partition starts at a predefined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L9"><code>SWAP_PARTITION_ADDRESS</code></a>
<ul>
<li>swap-space size is defined by <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L5"><code>SECTOR_SIZE</code></a> and must be larger than the largest sector in either <code>BOOT</code> or <code>UPDATE</code> partition.</li>
</ul>
</li>
</ul>
<p>BOOT, UPDATE, SWAP addresses and SECTOR_SIZE, PARTITION_SIZE values can be set via source files - <code>constants.rs</code>.</p>
<blockquote>
<p><strong>MCU defaults:</strong></p>
<ul>
<li>By default, public keys used for firmware validation are embedded in <code>rustBoot-firmware</code> during a factory image-burn. However, rustBoot also supports the option to retrieve them from secure-hardware (ex: crypto-elements).</li>
<li>The <code>BOOT</code> partition is the only partition from which we can boot a firmware image. The firmware image must be linked so that its entry-point is at address <code>256 + BOOT_PARTITION_ADDRESS</code>.</li>
<li><code>BOOT</code> firmware is responsible for downloading a new firmware image via a secure channel and installing it in the <code>UPDATE</code> partition. </li>
<li>To trigger an update, the <code>BOOT</code> firmware updates the <code>status byte</code> of the <code>UPDATE</code> partition and performs a reboot. This will allow the bootloader to <code>swap the contents</code> of <code>BOOT</code> partition with that of the <code>UPDATE</code> partition. </li>
</ul>
</blockquote>
<h2 id="linux-system-partitions"><a class="header" href="#linux-system-partitions">Linux system partitions:</a></h2>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/linux_partition.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/linux_partition.svg?raw=true" alt="partition" title="Simplified Block Diagram, linux system partition" /></a></p>
<p>To boot into a linux system, rustBoot includes support for the fat32 file-system. </p>
<p>Boot-storage media must contain a fat32 partition </p>
<ul>
<li>of at least 150 MiB to accommodate the bootloader, boot + update fit-images and other vendor-specific boot files and</li>
<li>to add rustBoot support for your board, you can either implement the <code>BlockDevice</code> trait for your board's boot-storage media <code>controller</code> or simply use an existing implementation from the repo.</li>
</ul>
<blockquote>
<p>Note: rustBoot comes with batteries-included. It provides <code>rusty</code> implementations for basic peripherals such as flash, uart, crypto, gpio (out of the box) along with the necessary arch-specific initialization routines.</p>
<ul>
<li>for example: the rustBoot implementation for <code>rpi4</code> includes bare-metal drivers for the on-board emmc controller, gpio and uart peripherals. </li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-boot--update"><a class="header" href="#secure-boot--update">Secure Boot &amp; Update</a></h1>
<p>rustBoot supports the following <code>boot and update</code> schemes, depending on the underlying device-type.</p>
<ul>
<li><a href="arch/secure_boot_update.html#mcu-updates"><code>mcu updates:</code></a> to boot and update bare-metal mcu-firmware using a simple <a href="arch/./partitions.html#micro-controller-partitions"><code>partitioning scheme</code></a></li>
<li><a href="arch/secure_boot_update.html#linux-system-updates"><code>linux-system updates:</code></a> to boot and update a linux system.</li>
</ul>
<h2 id="mcu-updates"><a class="header" href="#mcu-updates">mcu updates:</a></h2>
<p>rustBoot implements a small state machine leveraging rust's type-system to enforce compile-time state transition checks. Additionally, it uses the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html"><code>sealed-trait</code></a> pattern to declare and seal (all possible) valid <code>states</code> and <code>partitions</code>. </p>
<p>The image below captures rustBoot's state transitions.</p>
<p>Upon supplying power to a system, execution usually starts in an mcu's BootROM. The BootROM is a piece of immutable code, also referred to as the <code>root of trust</code>. BootROM(s) are programmed into an mcu's ROM in the factory and may support secure-boot i.e. the ability to cryptographically verify (and pass control to) a 2nd stage executable/binary. </p>
<p>In our case, <code>rustBoot</code> is the 2nd stage. It checks the <a href="arch/./secure_boot_update.html#partition-status">status</a> of <code>BOOT</code> and <code>UPDATE</code> partitions and drives the state machine forward, as shown in the image below.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>there may be many intermediate stages/executables between <code>BootROM</code> and <code>rustBoot</code>. </li>
<li>rustBoot assumes that the target device contains a <code>root of trust</code> with support for digitally verifying cryptographic signatures. </li>
<li>rustBoot will check for firmware integrity and authenticity at appropriate stages during boot/update/rollback.</li>
<li>booting, updating and rolling back are determined by the the state machine.</li>
</ul>
</blockquote>
<p><a href="https://github.com/UdayakumarHidakal/RustBoot-state-diagrams/blob/main/rustBoot_State_Diagram.svg?raw=true"><img src="https://github.com/UdayakumarHidakal/RustBoot-state-diagrams/blob/main/rustBoot_State_Diagram.svg?raw=true" alt="State Diagram" title="State diagram for rustBoot" /></a></p>
<h3 id="partition-status"><a class="header" href="#partition-status">partition status:</a></h3>
<p><a href="arch/./partitions.html#micro-controller-partitions"><code>rustBoot partitions</code></a> use a status byte to track the status of firmware in each partition. The status byte is a 1-byte field stored at the end of each partition. </p>
<p>Possible states are:</p>
<ul>
<li><code>STATE_NEW (0xFF):</code> The image was never staged for boot, or triggered for an update. If an image is present, no flags are active.</li>
<li><code>STATE_UPDATING (0x70):</code> Only valid in the <code>UPDATE</code> partition. The image is marked for update and should replace the current image in <code>BOOT</code>.</li>
<li><code>STATE_TESTING (0x10):</code> Only valid in the <code>BOOT</code> partition. The image has been just updated, and never completed its boot. If present after reboot, it means that the updated image failed to boot, despite being correctly verified. This particular situation triggers a rollback.</li>
<li><code>STATE_SUCCESS (0x00):</code> Only valid in the <code>BOOT</code> partition. The image stored in <code>BOOT</code> has been successfully staged at least once, and the update is now complete.</li>
</ul>
<h3 id="partition-sector-flags"><a class="header" href="#partition-sector-flags">partition sector flags:</a></h3>
<ul>
<li>When an update is triggered, the contents of <code>UPDATE</code> and <code>BOOT</code> are swapped one sector at a time. <code>SWAP</code> is used to temporarily hold a sector during the swap. This ensures that we always store a backup of the original firmware. </li>
<li>rustBoot keeps track of the state of each sector (during a swap), using 4 bits per sector at the end of the <code>UPDATE</code> partition. </li>
<li>Each <code>sector-swap</code> operation corresponds to a different flag-value for a sector in the sector flags area. This means if a swap operation is interrupted, it can be resumed upon reboot.</li>
</ul>
<h2 id="linux-system-updates"><a class="header" href="#linux-system-updates">linux-system updates:</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing-utilities"><a class="header" href="#signing-utilities">Signing Utilities</a></h1>
<p>As rustBoot supports 2 types of firmware image formats, depending on the underlying device i.e. either an</p>
<ul>
<li><a href="arch/./images.html#mcu-image-format"><code>mcu-image:</code></a> a simple 256-byte firmware image format for microcontrollers or a</li>
<li><a href="arch/./images.html#fit-image-format"><code>fit-image:</code></a> the flattened-image-tree format for systems capable of booting linux.</li>
</ul>
<p>rustBoot <code>rbsigner</code> utility can produce 2 different types signed images. </p>
<h3 id="signed-mcu-image"><a class="header" href="#signed-mcu-image">Signed mcu-image:</a></h3>
<p>To sign a mcu-image, rustBoot's <a href="https://github.com/nihalpasham/rustBoot/tree/main/rbsigner">image signing utility</a> takes 3 inputs</p>
<ul>
<li>an unsigned mcu-image. </li>
<li>a raw signing-key or ecdsa private key.</li>
<li>the ecdsa curve-type - (nistp256 only for now).</li>
</ul>
<p>There are 2 ways to sign a mcu-image</p>
<ul>
<li>First we build the image and then sign it using the following commands.</li>
</ul>
<pre><code> cargo [board-name] build pkgs-for

 cargo [board-name] sign pkgs-for [boot-version] [update-version]
</code></pre>
<pre><code>Note : Here stm32f411 is used as example board for signing.
</code></pre>
<pre><code>output:
command : cargo stm32f411 build pkgs-for

yashwanthsingh@Yashwanths-MBP rustBoot % cargo stm32f411 build pkgs-for
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/xtask stm32f411 build pkgs-for`
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/boot_fw_blinky_green/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.08s
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/updt_fw_blinky_red/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.08s
$ cargo build --release
    Finished release [optimized] target(s) in 0.07s
</code></pre>
<pre><code>output:
  command : cargo stm32f411 sign pkgs-for 1234 1235


  yashwanthsingh@Yashwanths-MBP rustBoot % cargo stm32f411 sign pkgs-for 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/xtask stm32f411 sign pkgs-for 1234 1235`
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_bootfw -O binary stm32f411_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_updtfw -O binary stm32f411_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f411_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1908 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f411_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1996 bytes.  

</code></pre>
<ul>
<li>Single command to build ,sign and flash.</li>
</ul>
<pre><code>cargo [board-name] build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<pre><code>output : 

command : cargo stm32f411 build-sign-flash rustBoot 1234 1235
yashwanthsingh@Yashwanths-MacBook-Pro rustBoot % cargo stm32f411 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target/debug/xtask stm32f411 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/boot_fw_blinky_green/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.10s
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/updt_fw_blinky_red/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.10s
$ cargo build --release
    Finished release [optimized] target(s) in 0.11s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_bootfw -O binary stm32f411_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_updtfw -O binary stm32f411_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f411_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1908 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f411_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1996 bytes.

$ probe-rs-cli erase --chip stm32f411vetx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip stm32f411vetx stm32f411_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 65.02KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  2.00KiB/ 2.00KiB @     677B/s (eta 0s )
    Finished in 2.057s
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f411vetx stm32f411_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 65.15KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  2.00KiB/ 2.00KiB @     679B/s (eta 0s )
    Finished in 2.052s
$ cargo flash --chip stm32f411vetx --release
    Finished release [optimized] target(s) in 0.08s
    Flashing /Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f411
     Erasing sectors ✔ [00:00:01] [##############################] 48.00KiB/48.00KiB @ 40.79KiB/s (eta 0s )
 Programming pages   ✔ [00:00:01] [##############################] 43.00KiB/43.00KiB @ 17.31KiB/s (eta 0s )
    Finished in 2.267s
yashwanthsingh@Yashwanths-MacBook-Pro rustBoot % 
</code></pre>
<h3 id="signed-fit-image"><a class="header" href="#signed-fit-image">Signed fit-image:</a></h3>
<p>To sign a fit-image, rustBoot's <a href="https://github.com/nihalpasham/rustBoot/tree/main/rbsigner">image signing utility</a> takes 3 inputs </p>
<ul>
<li>an unsigned fit-image in the above format</li>
<li>a raw signing-key or ecdsa private key</li>
<li>the ecdsa curve-type - (nistp256 only for now).</li>
</ul>
<p>Simply run the following command from root directory of the rustBoot project. </p>
<pre><code>cargo run ../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb ../boards/rbSigner/keygen/ecc256.der nistp256
</code></pre>
<p>In the above example:</p>
<ul>
<li><code>../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb</code> is the path to my fit-image </li>
<li><code>../boards/rbSigner/keygen/ecc256.der</code> is the path to my <code>test</code> signing-key</li>
<li><code>nistp256</code> is the type ecdsa curve I'd like to use. Its the only one supported for now.</li>
</ul>
<pre><code>Output: 

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/target/debug/rbsigner ../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb ../boards/rbSigner/keygen/ecc256.der nistp256`
signature: ecdsa::Signature&lt;NistP256&gt;([64, 147, 93, 99, 241, 5, 118, 167, 156, 150, 203, 234, 74, 207, 182, 243, 129, 143, 38, 2, 107, 85, 114, 145, 178, 163, 33, 153, 2, 100, 0, 114, 135, 18, 174, 183, 194, 110, 24, 186, 33, 36, 39, 105, 116, 74, 8, 118, 171, 237, 30, 108, 64, 205, 206, 14, 110, 226, 43, 143, 180, 193, 19, 33])
bytes_written: 62202019
</code></pre>
<p>In the above example, the <code>signed fit-image</code> will be stored at the following path - <code>../boards/bootloaders/rpi4/apertis/signed-rpi4-apertis.itb</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build--flash"><a class="header" href="#build--flash">Build &amp; Flash</a></h1>
<p>This section will detail the steps involved in building and flashing <code>rustBoot</code> onto a specific board. More precisely, it will cover the following topics.</p>
<ul>
<li><strong>Partitioning</strong>: 
<ul>
<li>rustBoot offers 2 different partitioning schemes, depending on the target device
<ul>
<li><a href="./arch/partitions.html#micro-controller-partitions"><code>microcontroller-partitions</code></a> </li>
<li><a href="./arch/partitions.html#linux-system-partitions"><code>linux-system partitions</code></a> </li>
</ul>
</li>
</ul>
</li>
<li><strong>Building</strong>: 
<ul>
<li>a rustBoot build usually involves 
<ul>
<li>compiling firmware i.e. boot and update firmware. </li>
<li>signing the compiled firmware. We have 2 different <a href="./arch/signing_utilities.html#signing-utilities">signing schemes</a>, depending on the target device.</li>
<li>compiling rustBoot i.e. the bootloader</li>
</ul>
</li>
</ul>
</li>
<li><strong>Programming</strong>: 
<ul>
<li>After building the required artefacts, the next step is to program the board's non-volatile storage memory.</li>
<li>Again, depending on the target device, we employ different loading/programming strategies.
<ul>
<li><em>mcu</em>(s): typically, rustBoot will use the <a href="https://github.com/knurling-rs/probe-run"><code>probe-run</code></a> utility for programming (and debugging).</li>
<li><em>sbc</em>(s): this will depending the on type of single-board computer. For example: the raspberry-pi uses a sd card for storage and booting.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Verifying</strong>: 
<ul>
<li>To verify that everything works as expected, rustBoot outputs boot-logs. 
<ul>
<li><em>mcu</em>(s): we use a combination of boot-logs and blinking-leds to verify that <code>secure boot and update</code> works as expected. For specifics, please refer to the <code>usage</code> page for the board.</li>
<li><em>sbc</em>(s): rustBoot simply outputs logs to a UART-terminal. For specifics, please refer to <code>usage</code> page for the board.</li>
</ul>
</li>
<li>Among other things, rustBoot logs will indicate <code>image-authentication</code> status. </li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: drivers for peripherals such as flash-memory, uart, gpio etc. are included for each board. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nrf52840"><a class="header" href="#nrf52840"><code>nrf52840</code></a></h1>
<p>The <code>nrf52840</code> example uses a <a href="https://wiki.makerdiary.com/nrf52840-mdk/">maker-diary board</a>. It has a custom led configuration. </p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning"><a class="header" href="#partitioning">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>nrf52840</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;nrf52840&quot;)]
pub const SECTOR_SIZE: usize = 0x1000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const PARTITION_SIZE: usize = 0x28000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x2f000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x57000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x58000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming"><a class="header" href="#compiling-signing-and-programming">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>nrf52840</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-powershell">cargo nrf52840 build-sign-flash rustBoot
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number must be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary. </li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash
cargo install cargo-binutils
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-powershell">PS C:\Users\Nil\devspace\rust\projects\rb&gt; cargo nrf52840 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
     Running `target/debug/xtask nrf52840 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
   Compiling rand_core v0.6.3
   Compiling subtle v2.4.1
   Compiling nb v1.0.0
   Compiling cfg-if v1.0.0
   ...
   ...
   Compiling rustBoot-hal v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/update)
   Compiling nrf52840_bootfw v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/firmware/nrf52840/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 10.60s
$ cargo build --release
   Compiling nrf52840_updtfw v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/firmware/nrf52840/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 0.43s
$ cargo build --release
   Compiling rand_core v0.6.3
   Compiling subtle v2.4.1
   Compiling cfg-if v1.0.0
   Compiling nb v1.0.0
   ...
   ...
   Compiling rustBoot-hal v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/update)
   Compiling nrf52840 v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/bootloaders/nrf52840)
    Finished release [optimized] target(s) in 10.96s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/nrf52840_bootfw -O binary nrf52840_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/nrf52840_updtfw -O binary nrf52840_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/nrf52840_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/nrf52840_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Image type:       mcu-image
Curve type:       nistp256
Input image:      nrf52840_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     nrf52840_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1696 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/nrf52840_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/nrf52840_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Image type:       mcu-image
Curve type:       nistp256
Input image:      nrf52840_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     nrf52840_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1724 bytes.

$ probe-rs-cli erase --chip nRF52840_xxAA
$ probe-rs-cli download --format Bin --base-address 0x2f000 --chip nRF52840_xxAA nrf52840_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:00] [##########]  4.00KiB/ 4.00KiB @ 15.97KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##########]  4.00KiB/ 4.00KiB @  6.77KiB/s (eta 0s )
    Finished in 0.73s
$ probe-rs-cli download --format Bin --base-address 0x58000 --chip nRF52840_xxAA nrf52840_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:00] [##########]  4.00KiB/ 4.00KiB @ 16.34KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##########]  4.00KiB/ 4.00KiB @  6.86KiB/s (eta 0s )
    Finished in 0.713s
$ cargo flash --chip nRF52840_xxAA --release
    Finished release [optimized] target(s) in 0.06s
    Flashing /Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/target/thumbv7em-none-eabihf/release/nrf52840
     Erasing sectors ✔ [00:00:01] [##########] 44.00KiB/44.00KiB @ 25.20KiB/s (eta 0s )
 Programming pages   ✔ [00:00:03] [##########] 44.00KiB/44.00KiB @  5.62KiB/s (eta 0s )
    Finished in 4.808s
</code></pre>
<h2 id="verifying"><a class="header" href="#verifying">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li><code>validates</code> the firmware image stored in the <code>BOOT</code> partition i.e.</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li><code>swaps</code> the contents of the <code>BOOT</code> and the <code>UPDATE</code> partitions</li>
<li>marks the new firmware in the <code>BOOT</code> partition as in state <code>STATE_TESTING</code></li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rp2040"><a class="header" href="#rp2040"><code>rp2040</code></a></h1>
<p>The <code>rp2040</code> example uses a <a href="https://www.raspberrypi.com/products/raspberry-pi-pico/">Raspberry Pi Pico Board</a>. The board has 1 user LED which will be blinking at different frequencies depending on whether we're executing boot-firmware or update-firmware.</p>
<h2 id="raspberry-pi-picos-boot-sequence"><a class="header" href="#raspberry-pi-picos-boot-sequence">Raspberry Pi Pico's Boot Sequence</a></h2>
<p>Raspberry Pi Pico board has an external QSPI Flash chip <code>W25Q080</code> with support for cached execute-in-place. 
It has a first stage bootloader baked into ROM. This is always the very first thing that runs when the RP2040 starts up.
The built-in bootloader has a fixed sequence,  it checks if the BOOTSEL button is pressed, and if so, enters the USB mass storage mode for code upload. 
If the BOOTSEL button is not pressed, and it looks like the flash contains a valid program, then it starts executing the “program” from flash.</p>
<p>In flash, first 256 bytes are second-stage bootloader which are required to configure external QSPI flash for high speed and efficient code access.</p>
<blockquote>
<p>Note:  For this example we are using two Pico boards, one board will be used as debug probe and other will be a target board. You can learn more about this <a href="https://wiki.freepascal.org/ARM_Embedded_Tutorial_-_Raspberry_Pi_Pico_Setting_up_for_Development">here</a></p>
</blockquote>
<h2 id="partitioning-1"><a class="header" href="#partitioning-1">Partitioning</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>Pico</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;rp2040&quot;)]
pub const SECTOR_SIZE: usize = 0x1000;
#[cfg(feature = &quot;rp2040&quot;)]
pub const PARTITION_SIZE: usize = 0x20000;
#[cfg(feature = &quot;rp2040&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x10020000;
#[cfg(feature = &quot;rp2040&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x10040000;
#[cfg(feature = &quot;rp2040&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x10060000;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Choose the number of sectors based on your boot and update firmware sizes.</p>
</blockquote>
<p><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x10000100</code>.</p>
<ul>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-1"><a class="header" href="#compiling-signing-and-programming-1">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>Pico</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32f334 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash
cargo install cargo-binutils
</code></pre>
<p>Here's the command and its output that should be produced.</p>
<pre><code class="language-Terminal">cargo rp2040 build-sign-flash rustBoot 1234 1235
</code></pre>
<pre><code>C:\Users\ABHISHEK\Documents\rustBoot&gt; cargo rp2040 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target\debug\xtask.exe rp2040 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
    Finished release [optimized] target(s) in 0.21s
$ cargo build --release
    Finished release [optimized] target(s) in 0.16s
$ cargo build --release
    Finished release [optimized] target(s) in 0.26s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv6m-none-eabi/release/rp2040_bootfw -O binary rp2040_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv6m-none-eabi/release/rp2040_updtfw -O binary rp2040_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/rp2040_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `C:\Users\ABHISHEK\Documents\rustBoot\target\debug\rbsigner.exe mcu-image ../boards/sign_images/signed_images/rp2040_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      rp2040_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     rp2040_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1644 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/rp2040_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `C:\Users\ABHISHEK\Documents\rustBoot\target\debug\rbsigner.exe mcu-image ../boards/sign_images/signed_images/rp2040_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      rp2040_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     rp2040_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1612 bytes.

$ probe-rs-cli download --format Bin --base-address 0x10020000 --chip RP2040 rp2040_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:00] [################################################################]  4.00KiB/ 4.00KiB @ 23.50KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [################################################################]  4.00KiB/ 4.00KiB @ 10.21KiB/s (eta 0s )
    Finished in 0.494s
$ probe-rs-cli download --format Bin --base-address 0x10040000 --chip RP2040 rp2040_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:00] [################################################################]  4.00KiB/ 4.00KiB @ 23.77KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [################################################################]  4.00KiB/ 4.00KiB @ 10.27KiB/s (eta 0s )
    Finished in 0.495s
$ cargo flash --chip RP2040 --release
    Finished release [optimized] target(s) in 0.18s
    Flashing C:\Users\ABHISHEK\Documents\rustBoot\boards\target\thumbv6m-none-eabi\release\rp2040
     Erasing sectors ✔ [00:00:00] [################################################################] 48.00KiB/48.00KiB @ 45.42KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [################################################################] 48.00KiB/48.00KiB @  9.73KiB/s (eta 0s )
    Finished in 3.174s
</code></pre>
<h2 id="verifying-1"><a class="header" href="#verifying-1">Verifying:</a></h2>
<p><code>user led</code> is used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>user led</code> for a few seconds, at an interval of <code>1 second</code> five times.
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware 
<ul>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>user led</code> at an interval of <code>0.125 second</code> continuously.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-4"><a class="header" href="#raspberry-pi-4"><code>raspberry-pi 4</code></a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents"><code>Table of contents:</code></a></h2>
<ul>
<li>  <a href="usage/./rpi4.html#---raspberry-pi-4-boot-sequence"><code>raspberry-pi 4 boot-sequence:</code></a>   🥧 </li>
<li>  <a href="usage/./rpi4.html#---rustboot-execution-sequence"><code>rustBoot execution-sequence:</code></a>   🦀 </li>
<li>  <a href="usage/./rpi4.html#---booting-from-an-sd-card"><code>Booting from an SD card:</code></a>   💾</li>
<li>  <a href="usage/./rpi4.html#---compiling-rustboot"><code>Compiling rustBoot:</code></a>   ⌛</li>
<li>  <a href="usage/./rpi4.html#---adding-a-root-file-system"><code>Adding a root file system:</code></a>   💼</li>
<li>  <a href="usage/./rpi4.html#---uart-communication"><code>UART communication:</code></a>   🚌</li>
<li>  <a href="usage/./rpi4.html#---power-on-and-test"><code>Power-on and test:</code></a>   🧪</li>
</ul>
<h3 id="---raspberry-pi-4-boot-sequence"><a class="header" href="#---raspberry-pi-4-boot-sequence">🥧   raspberry-pi 4 boot-sequence:</a></h3>
<p>rpi4 has an unconventional boot process</p>
<ul>
<li>Upon initial power-on, the <code>bcm2711</code> SoC (CPU is offline but GPU is powered on) executes from the onboard bootROM i.e. <code>1st stage bootloader</code> </li>
</ul>
<blockquote>
<p>Note: the GPU contains a tiny risc core that executes the <code>bootROM</code>. </p>
</blockquote>
<ul>
<li><code>bootROM</code> checks an onboard SPI-EEPROM for a 2nd stage bootloader</li>
<li>This <code>2nd stage bootloader</code> is loaded into the GPU's L2 cache for the GPU to execute. 
<ul>
<li>It initializes system clocks and SDRAM</li>
<li>loads GPU firmware (start4.elf) into RAM</li>
</ul>
</li>
<li>the <code>GPU firmware</code> performs RAM allocations i.e. 
<ul>
<li>RAM is shared between CPU and GPU </li>
<li>enables BCM7211 CPU.</li>
<li>loads <code>rustBoot-bootloader</code> from the SD card into CPU-assigned RAM and passes control of the ARMv8 core to rustBoot</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: At this point, rustBoot has complete control over the CPU. </p>
</blockquote>
<h3 id="---rustboot-execution-sequence"><a class="header" href="#---rustboot-execution-sequence">🦀   rustBoot execution-sequence:</a></h3>
<ul>
<li>By default, rpi4 will always start executing in EL2. Since we are booting a traditional Kernel (i.e. linux), we have to transition into the more appropriate EL1.</li>
</ul>
<blockquote>
<p>Note: EL1 and EL2 are abbreviations for ARMv8-A exception levels</p>
</blockquote>
<p>So, rustBoot checks the following</p>
<ul>
<li>is the core executing in <code>EL2</code>? </li>
<li>are we executing on the <code>boot-core</code> i.e. is it core 0? </li>
<li>if the answer to any of the above questions is <code>no</code>, then we park the core i.e. go into an infinite wait state.</li>
<li>If yes, then we initialize <code>DRAM</code>, <code>zero out bss</code>, transition to EL1 and finally jump to an early initialization routine called kernel_init.</li>
<li><code>kernel_init</code> is an early initialization routine. It takes care of the following - 
<ul>
<li>enables exception handling</li>
<li>enables the MMU along with instruction + data caching</li>
<li>initializes a small set of peripheral drivers i.e EMMC controller, UART, GPIO</li>
<li>and passes control to the core bootloader routine called kernel_main.</li>
</ul>
</li>
<li><code>kernel_main</code> takes care of loading, verifying and booting fit-images.
<ul>
<li>it uses rustBoot's (fat32) file-system to retrieve the first partition (or volume). </li>
</ul>
<blockquote>
<p>Note:  rustBoot does not support GUID Partition Table disks.</p>
</blockquote>
<ul>
<li>If the first volume is a <code>valid fat32</code> partition, it loads the supplied fit-image into RAM and attempts to verify its signature using the ecdsa algorithm.</li>
<li>If the fit-image is authentic i.e. the signature check passes, it relocates the following components to an appropriate location in memory. 
<ul>
<li><code>linux kernel</code></li>
<li><code>fdt or dtb</code></li>
<li><code>ramdisk or initramfs</code></li>
</ul>
</li>
<li>additionally, it will patch the dtb with any supplied (boot-time) kernel command-line arguments. </li>
</ul>
<blockquote>
<p>Note: kernel cmd-line arguments are set at package-build time i.e. when building the fit-image and cannot be interactively set at run time.</p>
</blockquote>
<ul>
<li>Finally, it disables the MMU and boots the linux kernel by jumping to its (relocated) entry point.</li>
</ul>
</li>
</ul>
<h3 id="---booting-from-an-sd-card"><a class="header" href="#---booting-from-an-sd-card">💾   Booting from an SD card:</a></h3>
<p>Raspberry Pi computers use a micro SD card to store a bootable image.</p>
<p><em>SD card preparation:</em> </p>
<ul>
<li>make 2 partitions 
<ul>
<li>the first one must be a <code>fat32</code> partition named <code>firmware</code>. The <code>fat</code> partition needs to be (at-least) 150MB(s). But to keep things simple, you can use a 256MB partition.</li>
<li>the second one can be <code>ext2/3/4</code> partition. This is used to host the root file system. </li>
</ul>
</li>
</ul>
<p><em>FAT32 partition contents:</em></p>
<ul>
<li>Create a file named <code>config.txt</code> with the following contents in the fat partition.</li>
</ul>
<pre><code>    arm_64bit=1
    enable_uart=1
    init_uart_clock=4000000
    kernel=rustBoot.bin
</code></pre>
<ul>
<li>Copy the following files from the Raspberry Pi firmware repo onto the fat partition:
<ul>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/fixup4.dat">fixup4.dat</a></li>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/start4.elf">start4.elf</a></li>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/bcm2711-rpi-4-b.dtb">bcm2711-rpi-4-b.dtb</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: Should it not work on your rpi4, try renaming start4.elf to start.elf (without the 4) on the SD card.</p>
</blockquote>
<h3 id="---compiling-rustboot"><a class="header" href="#---compiling-rustboot">⌛   <code>Compiling rustBoot:</code></a></h3>
<p>You must have rust installed. You can install rust by following the installation instructions <a href="https://www.rust-lang.org/tools/install">here</a>. After installing rust, you'll need to switch to rust's <code>nightly</code> toolchain and add the <code>aarch64</code> compilation-target. This will allow us to compile code for the rpi4 </p>
<pre><code class="language-powershell">rustup default nightly
rustup target add aarch64-unknown-none-softfloat
</code></pre>
<p>Additionally you'll need a few binary utilities to extract the bootloader as a <code>.bin</code> file. They can be installed via the following commands.</p>
<pre><code class="language-powershell">cargo install cargo-binutils
rustup component add llvm-tools-preview
</code></pre>
<p>To verify that you have the pre-requisites installed correctly, run the following command</p>
<pre><code class="language-powershell">rustup show
</code></pre>
<p>In my case, <code>rustup show</code> returns the following output. </p>
<pre><code class="language-powershell">rustup show
Default host: aarch64-apple-darwin
rustup home:  /Users/nihal.pasham/.rustup

installed toolchains
--------------------

stable-aarch64-apple-darwin
nightly-aarch64-apple-darwin (default)

installed targets for active toolchain
--------------------------------------

aarch64-apple-darwin
aarch64-unknown-none-softfloat
thumbv7em-none-eabihf

active toolchain
----------------

nightly-aarch64-apple-darwin (default)
rustc 1.63.0-nightly (ee160f2f5 2022-05-23)
</code></pre>
<p>You should be able to see <code>aarch64-unknown-none-softfloat</code> as one of the installed targets. To compile the rustBoot-bootloader, simply clone the <a href="https://github.com/nihalpasham/rustBoot"><code>rustBoot repo</code></a> and run the following command</p>
<pre><code class="language-powershell">cargo rpi4 build rustBoot-only
</code></pre>
<p>The above command should output the following (output will be longer when compiling for the first time) logs, produce an executable bootloader named <code>rustBoot.bin</code> and store it in the following path <code>./rustBoot/boards/bootloaders/rpi4</code></p>
<pre><code class="language-powershell">Output:
   Compiling xtask v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `target/debug/xtask rpi4 build rustBoot-only`
$ cargo build --release
   Compiling rustBoot v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/rustBoot)
   Compiling rustBoot-hal v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/hal)
   Compiling rpi4 v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/bootloaders/rpi4)
    Finished release [optimized] target(s) in 4.77s
$ rust-objcopy --strip-all -O binary ../../target/aarch64-unknown-none-softfloat/release/kernel rustBoot.bin
</code></pre>
<blockquote>
<p>If you run into any linker issues during the compilation process in a windows environment, please ensure you have C++ build tools installed on your machine. You can download and install the visual studio's build tools from the <a href="https://docs.microsoft.com/en-us/windows/dev-environment/rust/setup">microsoft website</a>.</p>
</blockquote>
<p>After compiling rustBoot, copy <code>rustBoot.bin</code> file onto the sd card's fat32 partition.</p>
<p>The last step in preparing a bootable SD card is to copy the rustBoot fit-image that you'd like to boot onto the sd card's fat32 partition.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>to build a rustBoot fit-image, you can follow <a href="usage/../arch/images.html#building-a-rustboot-compliant-fit-image">these instructions</a> and</li>
<li>to sign a fit-image, you can follow <a href="usage/../arch/images.html#signing-fit-images">these instructions</a>. </li>
</ul>
</blockquote>
<p>Finally, once you've added the above mentioned files to your sd card. The fat32 partition should contain the following files: </p>
<ul>
<li>  config.txt</li>
<li>  fixup4.dat</li>
<li>  start4.elf</li>
<li>  bcm2711-rpi-4-b.dtb</li>
<li>  rustBoot.bin</li>
<li>  signed-example-image.itb</li>
</ul>
<h3 id="---adding-a-root-file-system"><a class="header" href="#---adding-a-root-file-system">💼   Adding a root file system:</a></h3>
<p>There are many ways to add a root file-system to the second ext2/3/4 partition. One way is to copy a root file system to an empty ext2/3/4 drive: </p>
<ul>
<li>Maintainers of a linux distribution provide pre-built OS images. These images usually contain several partitions such as - 
<ul>
<li><code>boot:</code> contains the bootloader, kernel, dtb, ramdisk and other stuff</li>
<li><code>system:</code> contains the root file system </li>
<li><code>others:</code> may contain other partitions for things such as storage etc.</li>
</ul>
</li>
<li>simply download an OS image or a pre-built linux distribution from the maintainers website.
<ul>
<li>in this example, I'll be using the <a href="https://www.apertis.org/download/"><code>apertis</code></a> distribution.</li>
</ul>
</li>
<li>it’s usually in a compressed (zImage) format, decompress it using a tool like unarchiver to get a disk image.</li>
<li>use <code>partx --show</code> to list all partitions</li>
</ul>
<pre><code class="language-powershell">$ partx --show __linux_image_filepath__
NR  START     END SECTORS SIZE NAME UUID
 1   8192  532479  524288 256M      9730496b-01
 2 532480 3661823 3129344 1.5G      9730496b-02
</code></pre>
<ul>
<li>in the above example, partition 2 with a size of 1.5G contains the root file system. It's usually named <code>system</code>.</li>
<li>calculate the offset to the <code>system</code> volume/partition. You can do this with the <code>bc</code> command. </li>
</ul>
<blockquote>
<p><code>512</code> is the sector-size. We multiply sector-size with the sector offset to get the actual starting (byte) location of <code>system</code>.</p>
</blockquote>
<pre><code class="language-powershell">$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
&gt; 532480 * 512
&gt; 272629760
&gt; quit
</code></pre>
<ul>
<li>mount the partition as an <code>ext4 filesystem</code> </li>
</ul>
<pre><code>$ sudo mkdir /mnt/other
$ sudo mount -v -o offset=272629760 -t ext4 /_path_to_file_image/__filename__.img /mnt/other
mount: /dev/loop0 mounted on /mnt/other.

Check mounted image

$ ls /mnt/other
</code></pre>
<ul>
<li>copy all of (system partition's) contents to sd card's ext2/3/4 partition using the <code>cp</code> command. </li>
</ul>
<blockquote>
<p>Note:</p>
<ul>
<li>this method only works on linux or macOS and does not work on WSL2.</li>
<li>all symbolic links need to be copied. If required you can create symbolic links using <code>ln</code> command. Here' an example that creates a symbolic link called <code>sbin</code> to <code>usr/bin</code> </li>
</ul>
<pre><code class="language-powershell">ln -s usr/sbin sbin 
</code></pre>
</blockquote>
<h3 id="---uart-communication"><a class="header" href="#---uart-communication">🚌   UART communication:</a></h3>
<p>rustBoot will output boot-logs via the raspberry-pi 4's UART interface. These logs can be sent to a host computer (i.e. laptop/desktop).</p>
<p>We'll need extra hardware for this:</p>
<ul>
<li><strong>a usb-to-serial ttl converter:</strong> is a tiny piece of hardware that allows us to send serial data from the rpi4's uart interface to the host
<ul>
<li>You can find USB-to-serial cables that should work right away at <a href="https://www.amazon.de/dp/B0757FQ5CX/ref=cm_sw_r_tw_dp_U_x_ozGRDbVTJAG4Q">[1]</a> <a href="https://www.adafruit.com/product/954">[2]</a>, but many others will work too. Ideally, your cable is based on the CP2102 chip.</li>
<li>You connect it to GND and GPIO pins 14/15 as shown below.</li>
</ul>
</li>
</ul>
<p>Connect the USB-serial converter to your host computer as shown in the wiring diagram
<a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/USB-serial.png?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/USB-serial.png?raw=true" alt="wiring diagram" title="USB-Serial UART connection" /></a>.</p>
<ul>
<li>make sure that you DO NOT connect the power pin of the USB serial. Only RX/TX and GND.</li>
<li>connect the rpi4 to the (USB) power cable and observe the output:</li>
</ul>
<p><strong>Serial console:</strong>
To view rpi4's output on a host machine, you'll need a tool/app/console that handles sending and receiving of serial data. There are a number of ways to interact with a serial console. I'll be using </p>
<ul>
<li><code>minicom</code> on linux</li>
<li><code>screen</code> on the mac</li>
<li><code>terminal-s</code> on windows</li>
</ul>
<blockquote>
<p>❗ NOTE: 
Depending on your host operating system, the device name might differ. For example, on macOS, it might be something like /dev/tty.usbserial-0001. In this case, please give the name explicitly:</p>
</blockquote>
<ul>
<li><strong>Using minicom:</strong>
<ul>
<li>install minicom with <code>sudo apt-get install minicom</code>, so you can emulate a terminal connected over serial.</li>
<li>and run </li>
</ul>
<pre><code class="language-powershell">minicom -b 115200 -D /dev/tty.usbserial-0001
</code></pre>
<ul>
<li>boot the Pi.</li>
<li>within a few seconds, you should see data in your session.</li>
</ul>
</li>
<li><strong>Using screen:</strong>
<ul>
<li>on a mac, run </li>
</ul>
<pre><code class="language-powershell">screen /dev/tty.usbserial-0001 115200
</code></pre>
<ul>
<li>boot the Pi.</li>
<li>within a few seconds, you should see data in your session.</li>
</ul>
</li>
<li><strong>Using terminal-s:</strong>
<ul>
<li>on a windows machine, install terminal-s (a python-based serial terminal) with <code>pip install terminal-s</code></li>
<li>and run </li>
</ul>
<pre><code class="language-powershell">terminal-s
</code></pre>
<ul>
<li>no need to provide a baud-rate. It will auto-detect the port and baud-rate (assuming its lower than 115200).</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: </p>
<ul>
<li>To exit the screen session, press Ctrl-A, then Ctrl-K, and confirm you want to exit when using minicom or screen</li>
<li>To exit terminal-s, press Ctrl-]</li>
</ul>
</blockquote>
<h3 id="---power-on-and-test"><a class="header" href="#---power-on-and-test">🧪   Power-on and test:</a></h3>
<p>Now that you have a fully bootable SD card containing</p>
<ul>
<li>a <code>fat32 formatted</code> boot partition populated with the relevant boot files and</li>
<li>a <code>ext2/3/4 formatted</code> root-file-system</li>
</ul>
<p>and have your uart-usb interface set-up, you are now ready to flip the switch i.e. </p>
<ul>
<li>insert the sd card into the pi's sd slot and</li>
<li>supply power to your pi. </li>
</ul>
<p>Your serial console should now start <a href="https://github.com/nihalpasham/rustBoot/blob/main/boards/bootloaders/rpi4/debug.md">receiving boot-logs from the rpi4</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f411"><a class="header" href="#stm32f411"><code>stm32f411</code></a></h1>
<p>The <code>stm32f411</code> example uses a <a href="https://www.st.com/en/evaluation-tools/32f411ediscovery.html">STM32F411EDISCOVERY BOARD</a>.The board has four LEDs of which two LEDs are used in this example. </p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-2"><a class="header" href="#partitioning-2">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f411</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f411&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const PARTITION_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x08060000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08040000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-2"><a class="header" href="#compiling-signing-and-programming-2">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f411</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-MAC">cargo stm32f411 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code> cargo install probe-rs-cli 
 cargo install cargo-flash 
 cargo install cargo-binutils
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code>yashwanthsingh@Yashwanths-MacBook-Pro rustBoot % cargo stm32f411 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target/debug/xtask stm32f411 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/boot_fw_blinky_green/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.10s
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/firmware/stm32f411/updt_fw_blinky_red/.cargo/config.toml`
    Finished release [optimized] target(s) in 0.10s
$ cargo build --release
    Finished release [optimized] target(s) in 0.11s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_bootfw -O binary stm32f411_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f411_updtfw -O binary stm32f411_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f411_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1908 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f411_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f411_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f411_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1996 bytes.

$ probe-rs-cli erase --chip stm32f411vetx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip stm32f411vetx stm32f411_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 65.02KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  2.00KiB/ 2.00KiB @     677B/s (eta 0s )
    Finished in 2.057s
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f411vetx stm32f411_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 65.15KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  2.00KiB/ 2.00KiB @     679B/s (eta 0s )
    Finished in 2.052s
$ cargo flash --chip stm32f411vetx --release
    Finished release [optimized] target(s) in 0.08s
    Flashing /Users/yashwanthsingh/Yash/Projects/git_rustBoot_mcusigner/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f411
     Erasing sectors ✔ [00:00:01] [##############################] 48.00KiB/48.00KiB @ 40.79KiB/s (eta 0s )
 Programming pages   ✔ [00:00:01] [##############################] 43.00KiB/43.00KiB @ 17.31KiB/s (eta 0s )
    Finished in 2.267s
yashwanthsingh@Yashwanths-MacBook-Pro rustBoot % 
</code></pre>
<h2 id="verifying-2"><a class="header" href="#verifying-2">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f446-nucleo"><a class="header" href="#stm32f446-nucleo"><code>stm32f446 Nucleo</code></a></h1>
<p>The <code>stm32f446</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f446re.html">STM32F446 Nucleo Board</a>. The board has 1 user LED which will be blinking at different frequencies depending on whether we're executing boot-firmware or update-firmware.</p>
<blockquote>
<p>Note </p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-3"><a class="header" href="#partitioning-3">Partitioning</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f446</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f446&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const PARTITION_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x08060000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08040000;
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</p>
<ul>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-3"><a class="header" href="#compiling-signing-and-programming-3">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f446 Nucleo's</code> on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32f446 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.
With the respective firmware versions. </p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash
cargo install cargo-binutils
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-Terminal">anand@anand-VirtualBox:~/Desktop/dev_space/Prod/rustBoot_mcusigner$ cargo stm32f446 build-sign-flash rustBoot 1234 1235
Compiling version_check v0.9.4
   Compiling typenum v1.15.0
   Compiling subtle v2.4.1
   Compiling rand_core v0.6.3
   Compiling const-oid v0.7.1
   Compiling zeroize v1.4.3
   Compiling memchr v2.5.0
   Compiling cfg-if v1.0.0
   Compiling base16ct v0.1.1
   Compiling log v0.4.17
   Compiling opaque-debug v0.3.0
   Compiling cpufeatures v0.2.2
   Compiling anyhow v1.0.58
   Compiling minimal-lexical v0.2.1
   Compiling stable_deref_trait v1.2.0
   Compiling byteorder v1.4.3
   Compiling xshell-macros v0.1.17
   Compiling der v0.5.1
   Compiling ff v0.11.1
   Compiling as-slice v0.2.1
   Compiling group v0.11.0
...
...
Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/xtask stm32f446 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
    Finished release [optimized] target(s) in 0.03s
$ cargo build --release
    Finished release [optimized] target(s) in 0.03s
$ cargo build --release
    Finished release [optimized] target(s) in 0.03s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f446_bootfw -O binary stm32f446_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f446_updtfw -O binary stm32f446_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f446_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
   Compiling libc v0.2.126
   Compiling rustBoot v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot_mcusigner/rustBoot)
   Compiling filetime v0.2.17
   Compiling rbsigner v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot_mcusigner/rbsigner)
    Finished dev [unoptimized + debuginfo] target(s) in 1.18s
     Running `/home/anand/Desktop/dev_space/Prod/rustBoot_mcusigner/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f446_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f446_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f446_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 1948 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f446_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `/home/anand/Desktop/dev_space/Prod/rustBoot_mcusigner/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f446_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f446_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f446_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 2092 bytes.

$ probe-rs-cli erase --chip stm32f446retx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip stm32f446retx stm32f446_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:03] [##############################################################################################################] 128.00KiB/128.00KiB @ 37.61KiB/s (eta 0s )
 Programming pages   ✔ [00:00:01] [################################################################################################################]  2.00KiB/ 2.00KiB @     296B/s (eta 0s )
    Finished in 5.804s
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f446retx stm32f446_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:03] [##############################################################################################################] 128.00KiB/128.00KiB @ 37.75KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [################################################################################################################]  3.00KiB/ 3.00KiB @     353B/s (eta 0s )
    Finished in 6.273s
$ cargo flash --chip stm32f446vetx --release
    Finished release [optimized] target(s) in 0.03s
    Flashing /home/anand/Desktop/dev_space/Prod/rustBoot_mcusigner/boards/target/thumbv7em-none-eabihf/release/stm32f446
     Erasing sectors ✔ [00:00:03] [################################################################################################################] 48.00KiB/48.00KiB @ 11.88KiB/s (eta 0s )
 Programming pages   ✔ [00:00:21] [################################################################################################################] 43.00KiB/43.00KiB @  1.69KiB/s (eta 0s )
    Finished in 25.449s

</code></pre>
<h2 id="verifying-3"><a class="header" href="#verifying-3">Verifying:</a></h2>
<p><code>user led</code> is used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>user led</code> for a few seconds, at an interval of <code>0.5 seconds</code>.
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>user led</code> at an interval of <code>1 second</code>. </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>user led</code> at an interval of <code>1 second</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32h723"><a class="header" href="#stm32h723"><code>stm32h723</code></a></h1>
<p>The <code>stm32h723</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-h723zg.html">Nucleo-h723zg board</a>. The board has three <code>LEDs</code> of which two <code>LEDs</code> are used in this example.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-4"><a class="header" href="#partitioning-4">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32h723</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory.</p>
<blockquote>
<p>Note:</p>
<ul>
<li><a href="https://www.st.com/resource/en/application_note/an5342-error-correction-code-ecc-management-for-internal-memories-protection-on-stm32h7-series-stmicroelectronics.pdf">Error correction code</a> memory is a type of flash memory data storage that uses error correction code to detect and correct n-bit data corruption that occurs in memory.</li>
<li>Since the <strong>STM32H7</strong> series devices have a 10-bit <code>ECC</code> function, it is not possible to write partition status/sector flags more than once, so use a bigger <code>PARTITION_SIZE</code>. The last <code>128KB</code> sector in each partition will be reserved for bootloader flags or partition status.</li>
</ul>
</blockquote>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32h723&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const PARTITION_SIZE: usize = 0x40000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x080A0000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08060000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-4"><a class="header" href="#compiling-signing-and-programming-4">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32h723</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32h723 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites - probe-rs-cli, cargo-binutils and cargo-flash.</li>
</ul>
</blockquote>
<pre><code class="language-pre-requisites">$ cargo install probe-rs-cli

$ cargo install cargo-binutils

$ cargo install cargo-flash
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-Terminal">$ cargo stm32h723 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `target/debug/xtask stm32h723 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
   Compiling version_check v0.9.4
   Compiling typenum v1.15.0
   ...
   ...
   Compiling rustBoot-update v0.1.0 (/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/boards/update)
    Finished release [optimized] target(s) in 53.55s
$ cargo build --release
   Compiling stm32h723_updtfw v0.1.0 (/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/boards/firmware/stm32h723/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 1.54s
$ cargo build --release
   Compiling stm32h723 v0.1.0 (/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/boards/bootloaders/stm32h723)
    Finished release [optimized] target(s) in 2.25s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32h723_bootfw -O binary stm32h723_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32h723_updtfw -O binary stm32h723_updtfw.bin
$ cargo run mcu-image ../boards/rbSigner/signed_images/stm32h723_bootfw.bin nistp256 ../boards/rbSigner/keygen/ecc256.der 1234
   Compiling rbsigner v0.1.0 (/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/rbsigner)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
     Running `/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/rbSigner/signed_images/stm32h723_bootfw.bin nistp256 ../boards/rbSigner/keygen/ecc256.der 1234`

Update type       :Firmware
Curve type        :nistp256
Input image       :stm32h723_bootfw.bin
Public key        :ecc256.der
Image version     :1234
Output image      :stm32h723_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 4608 bytes.

$ cargo run mcu-image ../boards/rbSigner/signed_images/stm32h723_updtfw.bin nistp256 ../boards/rbSigner/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `/Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/target/debug/rbsigner mcu-image ../boards/rbSigner/signed_images/stm32h723_updtfw.bin nistp256 ../boards/rbSigner/keygen/ecc256.der 1235`

Update type       :Firmware
Curve type        :nistp256
Input image       :stm32h723_updtfw.bin
Public key        :ecc256.der
Image version     :1235
Output image      :stm32h723_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 4624 bytes.

$ probe-rs-cli erase --chip stm32h723ZGTx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip STM32H723ZGTx stm32h723_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:02] [############################] 128.00KiB/128.00KiB @ 63.21KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  5.00KiB/ 5.00KiB @  1.05KiB/s (eta 0s )
    Finished in 2.165s
$ probe-rs-cli download --format Bin --base-address 0x8060000 --chip STM32H723ZGTx stm32h723_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 64.68KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################]  5.00KiB/ 5.00KiB @  1.08KiB/s (eta 0s )
    Finished in 2.117s
$ cargo flash --chip stm32h723ZGTx --release
    Finished release [optimized] target(s) in 0.08s
    Flashing /Users/imrankhaleelsab/Imran/Boschspace/RB_workspace/rustBoot-mcusigner/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32h723
        WARN probe_rs::config::target &gt; Using custom sequence for STM32H7
     Erasing sectors ✔ [00:00:01] [############################] 128.00KiB/128.00KiB @ 66.35KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [##############################] 44.00KiB/44.00KiB @ 13.45KiB/s (eta 0s )
    Finished in 2.878s
</code></pre>
<h2 id="verifying-4"><a class="header" href="#verifying-4">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f746"><a class="header" href="#stm32f746"><code>stm32f746</code></a></h1>
<p>The <code>stm32f746</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f746zg.html">Nucleo-f746zg board</a>. The board has three <code>LEDs</code> of which two <code>LEDs</code> are used in this example.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-5"><a class="header" href="#partitioning-5">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f746</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory.</p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f746&quot;)]
pub const SECTOR_SIZE: usize = 0x40000; 
#[cfg(feature = &quot;stm32f746&quot;)]
pub const PARTITION_SIZE: usize = 0x40000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08040000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x080C0000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08080000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-5"><a class="header" href="#compiling-signing-and-programming-5">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f746</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32f746 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary. </li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash
cargo install cargo-binutils
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-Terminal">udayakumar@udayakumar-VirtualBox:~/devspace/rustBoot$ cargo stm32f746 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/xtask stm32f746 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
   Compiling stm32f746_bootfw v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/firmware/stm32f746/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 0.99s
$ cargo build --release
   Compiling stm32f746_updtfw v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/firmware/stm32f746/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 0.95s
$ cargo build --release
    Finished release [optimized] target(s) in 0.09s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f746_bootfw -O binary stm32f746_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f746_updtfw -O binary stm32f746_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f746_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
   Compiling libc v0.2.126
   Compiling rustBoot v0.1.0 (/home/udayakumar/devspace/rustBoot/rustBoot)
   Compiling filetime v0.2.17
   Compiling rbsigner v0.1.0 (/home/udayakumar/devspace/rustBoot/rbsigner)
    Finished dev [unoptimized + debuginfo] target(s) in 2.17s
     Running `/home/udayakumar/devspace/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f746_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f746_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f746_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 2780 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f746_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `/home/udayakumar/devspace/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f746_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f746_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f746_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 2748 bytes.

$ probe-rs-cli erase --chip stm32f746zgtx
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f746zgtx stm32f746_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:03] [################################################################################################################] 256.00KiB/256.00KiB @ 72.27KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [##################################################################################################################]  3.00KiB/ 3.00KiB @     353B/s (eta 0s )
    Finished in 6.153s
$ probe-rs-cli download --format Bin --base-address 0x8080000 --chip stm32f746zgtx stm32f746_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:03] [################################################################################################################] 256.00KiB/256.00KiB @ 72.63KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [##################################################################################################################]  3.00KiB/ 3.00KiB @     351B/s (eta 0s )
    Finished in 6.171s
$ cargo flash --chip stm32f746zgtx --release
    Finished release [optimized] target(s) in 0.08s
    Flashing /home/udayakumar/devspace/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f746
     Erasing sectors ✔ [00:00:02] [##################################################################################################################] 64.00KiB/64.00KiB @ 22.76KiB/s (eta 0s )
 Programming pages   ✔ [00:00:20] [##################################################################################################################] 43.00KiB/43.00KiB @  1.88KiB/s (eta 0s )
    Finished in 22.968s
udayakumar@udayakumar-VirtualBox:~/devspace/rustBoot$ 

</code></pre>
<h2 id="verifying-5"><a class="header" href="#verifying-5">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f334"><a class="header" href="#stm32f334"><code>stm32f334</code></a></h1>
<p>The <code>stm32f334</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f334r8.html">STM32F334 Nucleo-64 Board</a>. The board has 1 user LED which will be blinking at different frequencies depending on whether we're executing boot-firmware or update-firmware.</p>
<blockquote>
<p>Note </p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-6"><a class="header" href="#partitioning-6">Partitioning</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f334</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f334&quot;)]
pub const SECTOR_SIZE: usize = 0x1800; 
#[cfg(feature = &quot;stm32f334&quot;)]
pub const PARTITION_SIZE: usize = 0x1800;
#[cfg(feature = &quot;stm32f334&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x0800b800; //its is of 3 pages starting from this address as the boot firmware is 2.47KiB
#[cfg(feature = &quot;stm32f334&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x0800e800; //its is of 3 pages starting from this address
#[cfg(feature = &quot;stm32f334&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x0800d000; //its is of 3 pages starting from this address as the update firmware is 2.50KiB

&gt; Note: Choose the number of pages based on your boot and update firmware sizes.

<span class="boring">}
</span></code></pre></pre>
<p><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</p>
<ul>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-6"><a class="header" href="#compiling-signing-and-programming-6">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f334 Nucleo's</code> on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>the <code>ecc256.der</code> file contains a public-key and a private-key, the first 64 bytes being the public-key and remaining 32 bytes make up the private-key. </li>
<li>This is a test key file and is to be used for testing purposes only.</li>
</ul>
</blockquote>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32f334 build-sign-flash rustBoot [boot-ver] [updt-ver]
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>The <code>updt-ver</code> number should be greater than <code>boot-ver</code>.</li>
</ul>
</blockquote>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash 
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code>sarathk@sarath:~/stm32f/pull_req/rustBoot$ cargo stm32f334 build-sign-flash rustBoot 1234 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/xtask stm32f334 build-sign-flash rustBoot 1234 1235`
$ cargo build --release
   Compiling rustBoot-hal v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/boards/update)
   Compiling stm32f334_bootfw v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/boards/firmware/stm32f334/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 1.60s
$ cargo build --release
   Compiling stm32f334_updtfw v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/boards/firmware/stm32f334/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 1.17s
$ cargo build --release
   Compiling defmt v0.3.2
   Compiling defmt-macros v0.3.2
   Compiling critical-section v0.2.7
   Compiling defmt-parser v0.3.1
   Compiling bare-metal v1.0.0
   Compiling bitflags v1.3.2
   Compiling defmt-rtt v0.3.2
   Compiling stm32f334 v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/boards/bootloaders/stm32f334)
   Compiling proc-macro-error-attr v1.0.4
   Compiling proc-macro-error v1.0.4
    Finished release [optimized] target(s) in 9.29s
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f334_bootfw -O binary stm32f334_bootfw.bin
$ rust-objcopy -I elf32-littlearm ../../target/thumbv7em-none-eabihf/release/stm32f334_updtfw -O binary stm32f334_updtfw.bin
$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f334_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234
   Compiling libc v0.2.126
   Compiling filetime v0.2.17
   Compiling rustBoot v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/rustBoot)
   Compiling rbsigner v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/rbsigner)
    Finished dev [unoptimized + debuginfo] target(s) in 3.89s
     Running `/home/sarathk/stm32f/pull_req/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f334_bootfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1234`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f334_bootfw.bin
Public key:       ecc256.der
Image version:    1234
Output image:     stm32f334_bootfw_v1234_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 2508 bytes.

$ cargo run mcu-image ../boards/sign_images/signed_images/stm32f334_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `/home/sarathk/stm32f/pull_req/rustBoot/target/debug/rbsigner mcu-image ../boards/sign_images/signed_images/stm32f334_updtfw.bin nistp256 ../boards/sign_images/keygen/ecc256.der 1235`

Update type:    Firmware
Curve type:       nistp256
Input image:      stm32f334_updtfw.bin
Public key:       ecc256.der
Image version:    1235
Output image:     stm32f334_updtfw_v1235_signed.bin
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created with 2484 bytes.

$ probe-rs-cli erase --chip stm32f334r8tx
$ probe-rs-cli download --format Bin --base-address 0x800b800 --chip stm32f334r8tx stm32f334_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:01] [################################################################################################]  4.00KiB/ 4.00KiB @  1.81KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [################################################################################################]  3.00KiB/ 3.00KiB @     557B/s (eta 0s )
    Finished in 4.483s
$ probe-rs-cli download --format Bin --base-address 0x800d000 --chip stm32f334r8tx stm32f334_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [################################################################################################]  4.00KiB/ 4.00KiB @  1.85KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [################################################################################################]  3.00KiB/ 3.00KiB @     554B/s (eta 0s )
    Finished in 4.491s
$ cargo flash --chip stm32f334r8tx --release
    Finished release [optimized] target(s) in 0.08s
    Flashing /home/sarathk/stm32f/pull_req/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f334
     Erasing sectors ✔ [00:00:10] [################################################################################################] 44.00KiB/44.00KiB @  4.03KiB/s (eta 0s )
 Programming pages   ✔ [00:00:20] [################################################################################################] 43.00KiB/43.00KiB @  1.31KiB/s (eta 0s )
    Finished in 31.232s
</code></pre>
<h2 id="verifying-6"><a class="header" href="#verifying-6">Verifying:</a></h2>
<p><code>user led</code> is used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>user led</code> for a few seconds, at an interval of <code>1 second</code> three times.
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware 
<ul>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>user led</code> at an interval of <code>0.25 second</code> continuously. </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-coding-guidelines"><a class="header" href="#secure-coding-guidelines">Secure Coding guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-guide"><a class="header" href="#reference-guide">Reference Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improve <code>rustBoot</code>. Big shout-out to them!</p>
<blockquote>
<ol>
<li><a href="https://github.com/imrank03" title="@imrank03"><strong><code>Imran K</code></strong> <img height="13" width="12" src="https://unpkg.com/simple-icons@v7/icons/github.svg" /></a></li>
<li><a href="https://github.com/yashwanthsinghm" title="yashwanthsinghm"><strong><code>Yashwanth Singh M</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/strange21" title="strange21"><strong><code>Anand Gedam</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/UdayakumarHidakal" title="@UdayakumarHidakal"><strong><code>Udayakumar Hidakal</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/sarath3192" title="sarath3192"><strong><code>Bobbili Sarath Kumar</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/abhishekdhamale" title="abhishekdhamale"><strong><code>Abhishek Dhamale</code></strong> <img height="13" width="12" src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
</ol>
</blockquote>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
