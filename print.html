<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rustBoot Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Objectives</li><li class="chapter-item expanded "><a href="objectives.html"><strong aria-hidden="true">1.</strong> Goals</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li class="chapter-item expanded affix "><li class="part-title">Design and Architecture Overview</li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/core_components.html"><strong aria-hidden="true">3.1.</strong> Components of rustBoot</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arch/images.html"><strong aria-hidden="true">4.1.</strong> rustBoot Images</a></li><li class="chapter-item expanded "><a href="arch/partitions.html"><strong aria-hidden="true">4.2.</strong> rustBoot Partitions</a></li><li class="chapter-item expanded "><a href="arch/secure_boot_update.html"><strong aria-hidden="true">4.3.</strong> Secure-Boot & Update</a></li><li class="chapter-item expanded "><a href="arch/signing_utilities.html"><strong aria-hidden="true">4.4.</strong> Signing Utilities</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="user_guide.html"><strong aria-hidden="true">5.</strong> Build & Flash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/nrf52840.html"><strong aria-hidden="true">5.1.</strong> nrf52840</a></li><li class="chapter-item expanded "><a href="usage/rpi4.html"><strong aria-hidden="true">5.2.</strong> rpi4</a></li><li class="chapter-item expanded "><a href="usage/stm32f411.html"><strong aria-hidden="true">5.3.</strong> stm32f411</a></li><li class="chapter-item expanded "><a href="usage/stm32f446.html"><strong aria-hidden="true">5.4.</strong> stm32f446</a></li><li class="chapter-item expanded "><a href="usage/stm32h723.html"><strong aria-hidden="true">5.5.</strong> stm32h723</a></li><li class="chapter-item expanded "><a href="usage/stm32f746.html"><strong aria-hidden="true">5.6.</strong> stm32f746</a></li><li class="chapter-item expanded "><a href="usage/stm32f334.html"><strong aria-hidden="true">5.7.</strong> stm32f334</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Coding Guidelines and Testing</li><li class="chapter-item expanded "><a href="coding_guide.html"><strong aria-hidden="true">6.</strong> Coding guidelines</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">7.</strong> Testing</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuous Integration</li><li class="chapter-item expanded "><a href="continuous-integration.html"><strong aria-hidden="true">8.</strong> Continuous Integration</a></li><li class="chapter-item expanded affix "><li class="part-title">For Developers</li><li class="chapter-item expanded "><a href="for_developers/index.html"><strong aria-hidden="true">9.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for_developers/ref_guide.html"><strong aria-hidden="true">9.1.</strong> Reference Guide</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rustBoot Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/nihalpasham/rustBoot-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rustboot"><a class="header" href="#rustboot"><code>rustBoot</code></a></h1>
<p><em>by Nihal Pasham</em> </p>
<p>rustBoot is a standalone bootloader, written entirely in <code>Rust</code>, designed to run on anything from a microcontroller to a system on chip. It can be used to boot into bare-metal firmware or Linux.</p>
<h2 id="why-rustboot"><a class="header" href="#why-rustboot">Why rustBoot?</a></h2>
<p>rustBoot prioritizes the following above all else.</p>
<ul>
<li>keep only the bare-essentials</li>
<li>secure by default</li>
<li>low-integration complexity</li>
</ul>
<p><code>rustBoot</code> does the bare minimum needed to securely boot bare-metal firmware (or Linux) i.e. it has a really small <code>trusted computing base</code>. It is secure by default i.e. it <code>does not boot digitally unsigned firmware</code> and uses <code>memory-safe implementations</code> (for crypto and boot-logic) as the default. It also attempts to eliminate the high degree of integration-complexity involved in rolling a production-grade bootloader by adopting a <code>batteries-included</code> approach. </p>
<ul>
<li><em>For example, we include <code>flash device drivers for all supported boards</code>, written in safe Rust.</em></li>
</ul>
<h2 id="why-prioritize-the-above"><a class="header" href="#why-prioritize-the-above">Why prioritize the above?</a></h2>
<h3 id="trusted-computing-base"><a class="header" href="#trusted-computing-base">Trusted Computing Base:</a></h3>
<p>Open-source bootloaders have a large trusted computing base i.e. they (pretty much) resemble a mini operating system with </p>
<ul>
<li>a complete networking stack</li>
<li>a collection of device drivers and device-tree blob(s)</li>
<li>integrated debug and command shells</li>
<li>support for every possible filesystem you can think of.   </li>
<li>and more stuff.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> This includes <a href="https://github.com/u-boot/u-boot"><code>U-boot</code></a>, the de-facto standard in the embedded-systems world. <a href="https://github.com/nccgroup/depthcharge"><code>DepthCharge</code></a> is an example of a U-Boot hacking toolkit for security researchers and tinkerers, designed to exploit U-boot's large attack surface. </p>
</blockquote>
<p><a href="https://raw.githubusercontent.com/imrank03/rustBoot-book-diagrams/main/Mental_map.svg?raw=true"><img src="https://raw.githubusercontent.com/imrank03/rustBoot-book-diagrams/main/Mental_map.svg?raw=true" alt="mental_map_uboot_attack_surface" title="Mental map of U-boot attack surface" /></a></p>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory safety:</a></h3>
<p>A large TCB inevitably equates to a large attack surface. The vast majority of them are written in C or some combination of C and Assembly. <code>A quick analysis of CVEs</code> reported over the last 2 years (in u-boot, bare-box and other open-source ones) show that the bulk of them fall into the memory-safety category. </p>
<blockquote>
<p><strong>Note:</strong> <code>addressable attack surface</code> is much larger, the above <code>attack surface</code> is only compounded when we add boot-time driver vulnerabilities.</p>
</blockquote>
<h3 id="complexity--boot-time"><a class="header" href="#complexity--boot-time">Complexity &amp; boot-time:</a></h3>
<p>Custom secure boot implementations can <code>get quite complex and add latency</code> with </p>
<ul>
<li>redundant hierarchical digital signature verification trust chains or </li>
<li>elaborate parsing of custom header or container formats.</li>
</ul>
<h3 id="vendor-dependencies"><a class="header" href="#vendor-dependencies">Vendor dependencies:</a></h3>
<p>Vendor-specific or custom chain of trust dependencies make it difficult to port bootloader implementations across boards.  This is in-part attributable to <code>non-standards based solutions</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<p>Contrary to prevailing wisdom, writing your own secure-bootloader is a complex project. The effort involved in developing/integrating one can be overwhelming. For example, we'll need to address a plethora of accompanying tasks such as key-management, signing infrastructure, code-safety, trust-chains, reliable back-ups etc. before we even get to the <code>actual booting logic</code>. </p>
<p>rustBoot's purpose is to help simplify the entire process. Its primary goals are</p>
<ul>
<li><strong>complies with key requirements of the <a href="https://datatracker.ietf.org/wg/suit/about/">IETF-SUIT</a> standard</strong> i.e.
<ul>
<li>one of <code>SUIT's requirements</code> - transferring or downloading an <code>update</code> should be delegated to the firmware/OS to avoid <code>size or computational</code> limitations. In other words, the bootloader should NOT be required to download and install an update. This removes the need for a networking stack and provides for a drastic reduction in the bootloader's attack surface.</li>
<li>SUIT also does not mandate the use of specific protocols or data link interfaces to transfer <code>updates</code> to a device. </li>
<li>rustBoot fully complies with this requirement. </li>
</ul>
</li>
<li><strong>reliable updates:</strong>
<ul>
<li>reliable updates in rustBoot will take the form of
<ul>
<li><code>flash swap operations</code> for microcontroller based systems. We'll use the <code>boot/update based multi-slot partitioning method</code> to replace currently active firmware with a newly received update and at the same time store a back-up copy of it in a (passive) secondary partition.</li>
<li><code>ram swap operations</code> for more powerful system-on-chip boards which can boot Linux. </li>
</ul>
</li>
</ul>
</li>
<li><strong>predictability over performance:</strong> 
<ul>
<li>one of rustBoot's core design objectives is to keep it simple and avoid complexity. So, there will be little to no application of meta or async programming constructs. </li>
</ul>
<blockquote>
<p><strong>Note:</strong> We don't actually need the extra performance. rustBoot can hit sub-second <code>secure boot-times</code> as we've stripped it down to the bare-essentials. This assumes flash load times are fast enough and a firmware binary-blob size of &lt; 1MB.</p>
</blockquote>
</li>
<li><strong>zero-dynamic memory allocation:</strong>
<ul>
<li>to make it highly portable, apart from its modular design, rustBoot relies on a zero dynamic memory allocation architecture i.e. no heap required. </li>
</ul>
</li>
<li><strong>memory safety &amp; type-state programming:</strong> 
<ul>
<li>the entire bootloader is written in rust's safe-fragment with a limited set of well-defined api(s) for unsafe HW access.</li>
<li>as a consequence, it makes rustBoot immune to a whole host of memory safety bugs. ex: things like parsing image-headers (i.e. container-formats) in rustBoot is much safer.</li>
<li>rustBoot takes advantage of rust's powerful type-system to make <code>invalid boot-states, unrepresentable at compile time</code> and along with constructs such as sealed states, global singletons, it improves the overall security of the entire code-base.</li>
</ul>
</li>
</ul>
<blockquote>
<p>There is a plan to further add to rustBoot's high levels of assurance by leveraging <code>formal methods</code> such as</p>
<ul>
<li><code>property-based testing via symbolic execution:</code> to formally verify rustBoot's parser.</li>
<li><code>deductive verification:</code> for critical sections of code (ex: swapping contents of boot and update partitions).</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="features-currently-supported"><a class="header" href="#features-currently-supported">Features currently supported:</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
support for <code>ARM Cortex-M, Cortex-A</code> micro-architectures</li>
<li><input disabled="" type="checkbox" checked=""/>
support for multi-slot partitioning of microcontroller flash memory. This allows us to implement the <code>boot/update</code> approach for bare-metal <code>firmware updates</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
support for <code>Aarch64 linux</code> booting</li>
<li><input disabled="" type="checkbox" checked=""/>
elliptic curve cryptography for integrity and authenticity verification using <a href="https://github.com/RustCrypto"><code>RustCrypto</code></a> crates</li>
<li><input disabled="" type="checkbox" checked=""/>
a tiny hardware abstraction layer for non-volatile memory (i.e. flash) access.</li>
<li><input disabled="" type="checkbox" checked=""/>
anti-rollback protection via version numbering.</li>
<li><input disabled="" type="checkbox" checked=""/>
a fully memory safe core-bootloader implementation with safe parsers and firmware-update logic.</li>
<li><input disabled="" type="checkbox" checked=""/>
power-interruptible firmware updates along with the assurance of fall-back availability.</li>
</ul>
<h2 id="features-planned"><a class="header" href="#features-planned">Features planned:</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
switch to <code>rust-based signing tools</code> for manifest-header creation, key-generation and firmware signing to improve scalability and security (currently examples use a python implementation for this). </li>
<li><input disabled="" type="checkbox"/>
support for external flash devices (ex: SPI flash) and serial/console logging interfaces.</li>
<li><input disabled="" type="checkbox"/>
support for <code>ARM TrustZone-M and A</code> and certified <code>secure hardware elements</code> - microchip ATECC608a, NXP SE050, STSAFE-100</li>
<li><input disabled="" type="checkbox"/>
support for a highly secure and efficient <code>firmware transport</code> method over end-end mutually authenticated and encrypted channels via <a href="https://github.com/ockam-network/ockam/tree/develop/documentation/use-cases/end-to-end-encryption-with-rust#readme">ockam-networking-libraries</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p><code>rustBoot</code> aims to offer an OS and micro-architecture agnostic (i.e. highly portable) standards-based secure bootloader that's easy to integrate into existing embedded software projects. Its architecture is designed around a simple idea – <code>a bootloader handles ONLY the bare-essentials and offloads the rest to systems that are better suited for the job.</code> </p>
<h2 id="what-does-a-bootloader-actually-do"><a class="header" href="#what-does-a-bootloader-actually-do">What does a bootloader actually do?</a></h2>
<ol>
<li>it initializes (the bare-minimum) requisite hardware. Ex: cpu-core, flash, gpios, uart, (RAM and hardware secure elements if needed).</li>
<li>digitally verifies or authenticates firmware.</li>
<li>boots or passes control over to firmware or an OS i.e. <code>linux or RTOS or bare-metal</code> and</li>
<li>if an update is available, it validates and applies the update before performing a re-boot. </li>
</ol>
<p>In this chapter, we'll talk about rustBoot's design and its core components.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="components-of-rustboot"><a class="header" href="#components-of-rustboot">Components of rustBoot</a></h2>
<p>At its core, <code>rustBoot</code> is comprised of 4 components</p>
<ul>
<li>the core bootloader</li>
<li>a minimal hardware abstraction layer</li>
<li>fast and safe crypto drivers</li>
<li>rustBoot firmware interface</li>
</ul>
<h3 id="the-core-bootloader"><a class="header" href="#the-core-bootloader">The core bootloader</a></h3>
<ul>
<li>has a tiny trusted computing base i.e. its less than <code>32KB in size</code> when compiled to an executable.</li>
<li>this includes signature-based authentication, reliable firmware updates with rollbacks and protections against downgrades attacks.</li>
</ul>
<h3 id="a-minimal-hardware-abstraction-layer"><a class="header" href="#a-minimal-hardware-abstraction-layer">A minimal hardware abstraction layer</a></h3>
<p>rustBoot provides abstractions for the following hardware classes i.e. it exposes a tiny API for you to easily integrate the following types of hardware.</p>
<ul>
<li>flash memory controllers: NVMC, SPI-flash, EMMC block devices etc.</li>
<li>TrustZone: Cortex-M or Cortex-A </li>
<li>serial interfaces: UART(s), GPIO(s)</li>
</ul>
<blockquote>
<p><strong>Note:</strong> To minimize integrational complexity and enhance security, we already provide a number of different hardware drivers written in safe-rust. So, you can use <code>your own drivers using rust-ffi</code> or use existing ones from the repo.</p>
</blockquote>
<h3 id="fast-and-safe-crypto-drivers"><a class="header" href="#fast-and-safe-crypto-drivers">Fast and safe crypto drivers</a></h3>
<ul>
<li><code>hardware secure elements or accelerators:</code> again, rustBoot offers drivers for crypto hardware or you can use your own.
<ul>
<li>examples of supported vendor-specific crypto modules include <code>ATECC608a</code>.</li>
</ul>
</li>
<li><code>software implementations of crypto-libraries:</code> rustBoot uses the <code>RustCrypto</code> project as its software crypto provider. 
<ul>
<li>This includes all crates in the rustcrypto project - hashing, signing, verification, encryption etc.</li>
</ul>
</li>
</ul>
<h3 id="rustboot-firmware-interface"><a class="header" href="#rustboot-firmware-interface">rustBoot firmware interface</a></h3>
<ul>
<li>rustBoot complies with a key requirement of the <a href="https://datatracker.ietf.org/wg/suit/about/"><strong>IETF-SUIT</strong></a> standard and does not include a networking stack, instead networking is offloaded to the underlying firmware/OS. </li>
<li>Firmware updates are downloaded and stored in non-volatile storage.</li>
<li>In order to trigger the update, rustBoot provides a simple API that can be called from within bare-metal firmware or linux.</li>
</ul>
<blockquote>
<p>Note: In the above context, firmware refers to either linux or bare-metal firmware. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-overview"><a class="header" href="#high-level-overview">High Level Overview</a></h1>
<p>rustBoot's architecture reflects its focus on <code>simplicity and security</code>, above everything else. </p>
<p>For a high-level overview, you can think of rustBoot as operating in 2 independent stages. </p>
<ul>
<li><strong>Pre-handover stage:</strong> post power-on, the BootROM (or some other intermediate-stage bootloader) executes and hands control over to <code>rustBoot</code>. This is a stage where <code>rustBoot</code> has full <code>execution control</code>.</li>
<li><strong>Post-handover stage:</strong> firmware has begun executing and has complete <code>execution control</code>. Firmware uses a couple <code>rustBoot</code> dependencies to trigger and confirm updates.</li>
</ul>
<h2 id="pre-handover-stage"><a class="header" href="#pre-handover-stage">Pre-handover stage:</a></h2>
<ul>
<li>rustBoot provides a minimal hardware abstraction layer for a wide range of ARM microcontrollers (STM32, Nordic, Microchip etc.) and microprocessors (rpi4, NXP etc.). The HAL allows peripherals drivers to initialize requisite hardware such as flash memories, UART controllers, GPIO pins etc.</li>
<li>an optional software-based crypto library in-case you don't need (or use) dedicated crypto hardware.</li>
<li>rustBoot's core-bootloader houses all of the <code>actual boot-logic</code> such as
<ul>
<li>firmware image <code>integrity and authenticity verification</code> via digital signatures</li>
<li>power-interruptible firmware updates along with the assurance of fall-back availability. </li>
<li><code>FIT-Image and device tree</code> parsing while booting linux.</li>
<li>multi-slot partitioning of microcontroller flash memory</li>
<li><code>anti-rollback protection</code> via version numbering.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/pre_handover_stage.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/pre_handover_stage.svg?raw=true" alt="pre_handover_stage" title="Simplified Block Diagram, Pre handover stage:" /></a></p>
<h2 id="post-handover-stage"><a class="header" href="#post-handover-stage">Post-handover stage:</a></h2>
<ul>
<li>At this stage, control has been handed over to firmware (or linux).</li>
<li>rustBoot <code>does not</code> have a networking stack. The job of downloading and installing an update is offloaded to firmware or linux (<a href="index.html#trusted-computing-base"><code>drastically reducing the TCB</code></a>)</li>
<li>Firmware can trigger and confirm updates by setting the state of the <code>update</code> partition via a rustBoot api. This removes the need for a filesystem (<a href="index.html#trusted-computing-base"><code>again smaller TCB</code></a>). 
<ul>
<li>However, not all systems can boot without a file-system. </li>
<li>If you need one, rustBoot offers a FAT 16/32 implementation, written in safe rust. </li>
</ul>
</li>
<li>Once an update is triggered, the device is reset (i.e. restarted). rustBoot takes over and attempts to verify the update. If everything checks out, it boots the updated firmware.</li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/post_handover_stage.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/post_handover_stage.svg?raw=true" alt="post_handover_stage" title="Simplified Block Diagram, Post handover stage:" /></a></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>rustBoot <code>can replace U-boot</code> in a trust-chain i.e. it can easily be integrated into an existing trust-chain, wherever U-boot is used.</li>
<li>As it has a very small hardware abstraction layer, it is highly portable across Cortex-M and Cortex-A architectures. </li>
<li>Public-key hashes or trust anchors can be stored in secure hardware or embedded in software.</li>
<li>Hardware drivers for different types of secure-hardware (ex: crypto elements) will be made available via the HAL. </li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustboot-images"><a class="header" href="#rustboot-images">rustBoot Images</a></h1>
<p>rustBoot supports 2 types of firmware image formats, depending on the underlying device. It could either be an</p>
<ul>
<li><a href="arch/./images.html#mcu-image-format"><code>mcu-image:</code></a> a simple 256-byte firmware image format for microcontrollers or a</li>
<li><a href="arch/./images.html#fit-image-format"><code>fit-image:</code></a> the flattened-image-tree format for systems capable of booting linux.</li>
</ul>
<h2 id="mcu-image-format"><a class="header" href="#mcu-image-format">MCU image format</a></h2>
<p>rustBoot mcu-images comprise of a <code>256-byte header</code> pre-pended to a firmware binary and are deliberately designed to be as simple as possible. </p>
<ul>
<li>it does not rely on the use of complex digital certificate formats which keeps the <a href="arch/../index.html#trusted-computing-base"><code>TCB</code></a> small and avoids unnecessary <a href="arch/../index.html#complexity--boot-time">code-complexity</a></li>
</ul>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/rustBoot_header.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/rustBoot_header.svg?raw=true" alt="rustBoot_header" title="Simplified Block Diagram, 256 byte rustBoot header" /></a></p>
<h3 id="rustboot-image-header-layout"><a class="header" href="#rustboot-image-header-layout">rustBoot image header layout:</a></h3>
<p>The header always starts with a 4-byte magic number, followed by a 4-byte field indicating the size of the firmware image (excluding the header). All header contents are stored in little-endian format.</p>
<p>The 2 (<code>magic and size</code>) fixed fields are followed by one or more <code>TLV(s) or Type, Length, Value</code> tags. A TLV has the following layout</p>
<ul>
<li><strong>Type:</strong> 2 bytes to indicate the <code>Type</code> of the tag</li>
<li><strong>Length:</strong> 2 bytes to indicate the <code>length in bytes</code> of the tag (excluding the type and size bytes).</li>
<li><strong>Value:</strong> N bytes of tag content</li>
</ul>
<h3 id="padding-and-end-of-header-bytes"><a class="header" href="#padding-and-end-of-header-bytes">Padding and End of header bytes:</a></h3>
<ul>
<li>An <code>0xFF</code> byte in the <code>Type</code> field indicates a padding byte. A 'padding' byte does <em>NOT</em> have a size field, and the next byte is interpreted as <code>Type</code> again.</li>
<li>A 2 byte value of <code>0x0000</code> signals the end of the rustBoot header. </li>
</ul>
<h3 id="tags"><a class="header" href="#tags">Tags:</a></h3>
<p>Each tag represents some information about the firmware. <code>rustBoot</code> requires the following <code>Tags</code> for firmware validation:</p>
<ul>
<li>The <code>version</code> tag provides firmware version number information.
<ul>
<li>Type: <code>0x0001</code></li>
<li>Length: 4 bytes</li>
</ul>
</li>
<li>The <code>timestamp</code> tag provides the timestamp in unix seconds for when the <code>rustBoot image</code> was created.
<ul>
<li>Type: <code>0x0002</code></li>
<li>Length: 8 bytes</li>
</ul>
</li>
<li>The <code>auth type</code> tag identifies the type of the authentication mechanism in use. Ex: which ECC curve are we using and what's the key strength etc.
<ul>
<li>Type: <code>0x0030</code></li>
<li>Length: 2 bytes</li>
</ul>
</li>
<li>The <code>sha256 digest</code> tag contains a <code>SHA2 hash</code> of the firmware and is used to check firmware integrity.
<ul>
<li>Type: <code>0x0003</code></li>
<li>Length: <code>32 bytes</code></li>
</ul>
</li>
<li>The <code>firmware signature</code> tag contains the <code>ECC signature</code> and is used to verify firmware against a known public key.
<ul>
<li>Type: <code>0x0020</code></li>
<li>Length: 64 bytes</li>
</ul>
</li>
</ul>
<h3 id="optional-tags"><a class="header" href="#optional-tags">Optional tags:</a></h3>
<ul>
<li><strong>Pubkey Hint:</strong> A <code>pubkey hint digest</code> tag can be included in the header.
<ul>
<li>Type: <code>0x1000</code></li>
<li>Length: 32 bytes</li>
<li>This tag contains the SHA256 digest of the public key of the corresponding private-key used by the signing tool. The bootloader may use this field to locate the correct public key in case multiple keys are available.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>MCU defaults:</strong> </p>
<ul>
<li>By default, a valid rustBoot image is always signed.</li>
<li>It relies on the 256-byte header for firmware validation.</li>
<li>It will fail to boot an image
<ul>
<li>if it does not possess a <a href="arch/images.html#rustboot-images"><code>valid rustBoot header</code></a> or</li>
<li>if it isn't signed or if it cannot be verified using the included the <a href="arch/images.html#tags"><code>authentication-type</code></a>.</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="fit-image-format"><a class="header" href="#fit-image-format">FIT-image format</a></h2>
<p>rustBoot leverages Uboot's <a href="https://raw.githubusercontent.com/u-boot/u-boot/master/doc/uImage.FIT/howto.txt"><code>flattened-uImage-tree</code></a> format to boot the linux kernel. </p>
<p>The FIT format is essentially an extension of  the <a href="https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.4-rc1"><code>device-tree</code></a> format. FIT allows us to combine multiple binaries such as the kernel, ramdisk, device-tree-blob etc. into a single image. </p>
<p>A typical rustBoot fit-image contains 4 items in the following order</p>
<ul>
<li>  kernel</li>
<li>  fdt</li>
<li>  initrd</li>
<li>  rbconfig</li>
</ul>
<h3 id="an-example-fit-image-source-file"><a class="header" href="#an-example-fit-image-source-file">An example fit-image source file:</a></h3>
<p>It is also referred to as an <code>image-tree</code> source file or <code>.its</code> file.</p>
<pre><code class="language-json">/dts-v1/;

/ {
        description = &quot;rustBoot FIT Image&quot;;
        #address-cells = &lt;1&gt;;

        images {
                kernel {
                        description = &quot;Kernel&quot;;
                        data = /incbin/(&quot;vmlinuz&quot;);     
                        type = &quot;kernel&quot;;
                        arch = &quot;arm64&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        load = &lt;0x40480000&gt;;
                        entry = &lt;0x40480000&gt;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                fdt {
                        description = &quot;DTB&quot;;
                        data = /incbin/(&quot;unpatched-bcm2711-rpi-4-b.dtb&quot;);
                        type = &quot;flat_dt&quot;;
                        arch = &quot;arm64&quot;;
                        compression = &quot;none&quot;;
                        load = &lt;0x43000000&gt;;
                        entry = &lt;0x43000000&gt;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                initrd {
                        description = &quot;Initrd&quot;;
                        data = /incbin/(&quot;initramfs&quot;);
                        type = &quot;ramdisk&quot;;
                        arch = &quot;arm64&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
                rbconfig {
                        description = &quot;rustBoot Config&quot;;
                        data = /incbin/(&quot;rbconfig.txt&quot;);
                        type = &quot;rustBoot cmdline config&quot;;
                        arch = &quot;none&quot;;
                        os = &quot;linux&quot;;
                        compression = &quot;none&quot;;
                        hash {
                                algo = &quot;sha256&quot;;
                        };
                };
        };

        configurations {
                default = &quot;bootconfig&quot;;
                bootconfig {
                        description = &quot;Boot Config&quot;;
                        kernel = &quot;kernel&quot;;
                        fdt = &quot;fdt&quot;;
                        ramdisk = &quot;initrd&quot;;
                        rbconfig = &quot;rbconfig&quot;;
                        signature@1 {
				algo = &quot;sha256,ecdsa256,nistp256&quot;;
				key-name-hint = &quot;dev&quot;;
				signed-images = &quot;fdt&quot;, &quot;kernel&quot;, &quot;ramdisk&quot;, &quot;rbconfig&quot;;
                                value = &quot;&quot;;
			};
                };
        };

};
</code></pre>
<p>The default configuration of an <code>.its</code> file determines which kernel, initrd, fdt and rbconfig is to be used for booting. In the above example, <code>bootconfig</code> is our default configuration. </p>
<blockquote>
<p>rustBoot's FIT parser will select the corresponding kernel, fdt, initrd and rbconfig associated with <code>bootconfig</code> for booting</p>
</blockquote>
<h3 id="building-a-rustboot-compliant-fit-image"><a class="header" href="#building-a-rustboot-compliant-fit-image">Building a rustBoot compliant fit-image:</a></h3>
<p>As shown in the example above, a rustBoot compliant fit-image contains 4 items - </p>
<ul>
<li><code>kernel</code> - the linux kernel </li>
<li><code>fdt</code> - the flattened device tree or device tree blob</li>
<li><code>ramdisk</code>- a root filesystem that is embedded into the kernel and loaded at an early stage of the boot process. It is the successor of initrd. It can do things the kernel can't easily do by itself during the boot process. For example: customize the boot process (e.g., print a welcome message) </li>
<li><code>rbconfig</code> - this is rustBoot's kernel configuration. A simple <code>txt</code> file to add kernel command-line arguments.</li>
</ul>
<p>You can retrieve the first 3 (i.e. kernel, fdt, ramdisk) from a pre-built OS image: </p>
<ul>
<li>Maintainers of a linux distribution provide pre-built OS images. These images usually contain several partitions such as - 
<ul>
<li><code>boot:</code> contains the bootloader, kernel, dtb, ramdisk and other stuff</li>
<li><code>system:</code> contains the root file system </li>
<li><code>others:</code> may contain other partitions for things such as storage etc.</li>
</ul>
</li>
<li>simply download an OS image or a pre-built linux distribution from the maintainers website.
<ul>
<li>in this example, I'll be using the <a href="https://www.apertis.org/download/"><code>apertis</code></a> distribution.</li>
</ul>
</li>
<li>it’s usually a compressed (zImage) format, decompress it using a tool like unarchiver to get a disk image.</li>
<li>use <code>partx --show</code> to list all partitions</li>
</ul>
<pre><code class="language-powershell">$ partx --show __linux_image_filepath__
NR  START     END SECTORS SIZE NAME UUID
 1   8192  532479  524288 256M      9730496b-01
 2 532480 3661823 3129344 1.5G      9730496b-02
</code></pre>
<p>In the above case, the first partition with a size of 256MB contains the boot-files. It's usually named <code>boot</code>. We can calculate the offset to the <code>boot</code> volume/partition with the following command </p>
<pre><code class="language-powershell">$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
&gt; 8192 * 512
&gt; 4194304
&gt; quit
</code></pre>
<blockquote>
<p><code>512</code> is the sector-size. We multiply sector-size with the sector offset to get the actual starting (byte) location of <code>boot</code>.</p>
</blockquote>
<p>mount the partition as an <code>ext4</code> file-system (or <code>fat</code> file-system, whichever)</p>
<pre><code>$ sudo mkdir /mnt/other
$ sudo mount -v -o offset=4194304 -t ext4 /_path_to_file_image/__filename__.img /mnt/other
mount: /dev/loop0 mounted on /mnt/other.

Check mounted image

$ ls /mnt/other
</code></pre>
<p>Copy the <code>dtb</code>, <code>ramdisk</code> and <code>vmlinuz</code> image (i.e. kernel) from the mounted partition to a new folder. You can give it any name you want. I'll use <code>pkg</code> for this example.</p>
<blockquote>
<p>vmlinuz is a PE (portable executable) i.e. we can jump to it and it will in-turn jump to the kernel's entry point.</p>
</blockquote>
<p><code>rbconfig:</code> Lastly, create a file named <code>rbconfig.txt</code> in the pkg folder. This file will be used by rustBoot to pass command-line parameters to the linux kernel. </p>
<p>Here's an example of the <code>rbconfig.txt</code> file -</p>
<pre><code class="language-powershell">bootargs=&quot;root=UUID=64bc182a-ca9d-4aa1-8936-d2919863c22a rootwait ro plymouth.ignore-serial-consoles fsck.mode=auto fsck.repair=yes cma=128M&quot;
</code></pre>
<p>When you have added all 4 items to the <code>pkg</code> folder, you can build a fit-image by running the following commands. </p>
<p><strong>On a mac:</strong> </p>
<pre><code class="language-powershell">brew install u-boot-tools
</code></pre>
<p><strong>On a linux machine:</strong></p>
<pre><code class="language-powershell">sudo apt install u-boot-tools
</code></pre>
<p>and then run </p>
<pre><code class="language-powershell">mkimage -f rpi4-apertis.its rpi4-test-apertis.itb
</code></pre>
<blockquote>
<ul>
<li>the input to <code>mkimage</code> is an <code>.its</code> file.</li>
<li>and <code>.itb</code> filename we've specified is the name given to the generated fit-image (that's stored in the <code>pkg</code> folder). </li>
<li>you can copy the contents of the example <a href="arch/./images.html#an-example-fit-image-source-file"><code>fit-image</code></a> file above into a new <code>.its</code> file named <code>rpi4-apertis.its</code> and add it to the pkg folder.</li>
</ul>
</blockquote>
<pre><code>Output:

rpi4-apertis.its:65.37-70.6: Warning (unit_address_vs_reg): /configurations/bootconfig/signature@1: node has a unit name, but no reg or ranges property
Image contains unit addresses @, this will break signing
FIT description: rustBoot FIT Image
Created:         Sat Jun  4 13:18:45 2022
 Image 0 (kernel)
  Description:  Kernel
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Kernel Image
  Compression:  uncompressed
  Data Size:    29272576 Bytes = 28586.50 KiB = 27.92 MiB
  Architecture: AArch64
  OS:           Linux
  Load Address: 0x40480000
  Entry Point:  0x40480000
  Hash algo:    sha256
  Hash value:   97dcbff24ad0a60514e31a7a6b34a765681fea81f8dd11e4644f3ec81e1044fb
 Image 1 (fdt)
  Description:  DTB
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Flat Device Tree
  Compression:  uncompressed
  Data Size:    25713 Bytes = 25.11 KiB = 0.02 MiB
  Architecture: AArch64
  Load Address: 0x43000000
  Hash algo:    sha256
  Hash value:   3572783be74511b710ed7fca9b3131e97fd8073c620a94269a4e4ce79d331540
 Image 2 (initrd)
  Description:  Initrd
  Created:      Sat Jun  4 13:18:45 2022
  Type:         RAMDisk Image
  Compression:  uncompressed
  Data Size:    32901194 Bytes = 32130.07 KiB = 31.38 MiB
  Architecture: AArch64
  OS:           Linux
  Load Address: unavailable
  Entry Point:  unavailable
  Hash algo:    sha256
  Hash value:   f1290587e2155e3a5c2c870fa1d6e3e2252fb0dddf74992113d2ed86bc67f37c
 Image 3 (rbconfig)
  Description:  rustBoot Config
  Created:      Sat Jun  4 13:18:45 2022
  Type:         Unknown Image
  Compression:  uncompressed
  Data Size:    141 Bytes = 0.14 KiB = 0.00 MiB
  Hash algo:    sha256
  Hash value:   b16d058c4f09abdb8da98561f3a15d06ff271c38a4655c2be11dec23567fd519
 Default Configuration: 'bootconfig'
 Configuration 0 (bootconfig)
  Description:  Boot Config
  Kernel:       kernel
  Init Ramdisk: initrd
  FDT:          fdt
  Sign algo:    sha256,ecdsa256,nistp256:dev
  Sign value:   00
  Timestamp:    unavailable
</code></pre>
<p>This <code>.itb</code> file is our fit-image. It does not contain a signature yet i.e. it is not signed - notice the <code>sign-value</code> field is empty. </p>
<h3 id="signing-fit-images"><a class="header" href="#signing-fit-images">Signing fit-images</a></h3>
<p>rustBoot fit-images are signed with <code>ecdsa256</code>. The signature includes the kernel, fdt, initrd and rbconfig. </p>
<p>Signing a rustBoot fit-image involves 2 steps: </p>
<ul>
<li><strong>Building a fit-image:</strong> As explained in <a href="arch/./images.html#building-a-rustboot-compliant-fit-image">preceding section</a>, FIT images can be built using <code>mkimage</code> - a command-line utility from the <code>uboot-tools</code> package i.e. you can pass an <code>.its</code> file to the mkimage tool and mkimage will produce an <code>.itb</code> blob or a image-tree blob.</li>
<li><strong>signing the fit-image:</strong>  once you've built your fit-image, you can pass the it along with a signing key to rustBoot's <code>rbsigner</code> utility to <a href="arch/./signing_utilities.html#signed-fit-image">generate a signed fit-image</a>. </li>
</ul>
<blockquote>
<p><strong>FIT-image defaults:</strong> </p>
<ul>
<li>By default, valid rustBoot images are always signed.</li>
<li>It will fail to boot an image
<ul>
<li>if the image fails fit-validation i.e. if its not a properly formatted fit-image or if the fit-parser cant find the specified default config or its components. </li>
<li>if it isn't signed or if it cannot be verified using the specified algo.</li>
</ul>
</li>
<li>rustBoot's fit parser currently supports the following architectures
<ul>
<li><code>Aarch64</code></li>
</ul>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustboot-partitions"><a class="header" href="#rustboot-partitions"><code>rustBoot Partitions</code></a></h1>
<p><code>rustBoot</code> has 2 distinct partitioning schemes, depending on the type of the underlying system.</p>
<ul>
<li><a href="arch/./partitions.html#micro-controller-partitions"><strong>micro-controller partitions:</strong></a> uses the concept of <a href="https://github.com/nihalpasham/rustBoot/issues/2"><code>swappable flash partitions</code></a> to update micro-controller firmware. 
<blockquote>
<p>This usually means bare-metal firmware but it is also applicable to <code>RTOS(s)</code>.</p>
</blockquote>
</li>
<li><a href="arch/./partitions.html#linux-system-partitions"><strong>linux system partitions:</strong></a> uses a single fat32 partition to host the <code>rustBoot-bootloader</code> and  (boot/update) fit-images. This method uses a <code>rustBoot-state</code> file to determine which image is to be booted.</li>
</ul>
<h2 id="micro-controller-partitions"><a class="header" href="#micro-controller-partitions">Micro-controller Partitions:</a></h2>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/partition.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/partition.svg?raw=true" alt="partition" title="Simplified Block Diagram, 256 byte rustBoot header" /></a></p>
<blockquote>
<p>Note: <code>BOOT</code>, <code>UPDATE</code> and <code>SWAP</code> partitions need <strong>NOT</strong> be consecutively laid out in flash memory. The above diagram only serves as a visual aid.</p>
</blockquote>
<p>rustBoot requires <code>mcu flash</code> to be divided into (at-least) 4 non-overlapping memory regions (i.e. partitions). </p>
<ul>
<li><code>rustBoot</code>: contains the bootloader. This usually starts at <code>address 0x0</code> in flash-memory. </li>
<li><code>BOOT:</code> contains boot firmware. <code>rustBoot</code> always boots from this partition address.</li>
<li><code>UPDATE:</code> contains update firmware i.e. downloaded update firmware is placed in this partition.</li>
<li><code>SWAP:</code> is an empty partition that is used while swapping contents of <code>BOOT</code> and <code>UPDATE</code>.</li>
</ul>
<p>All 3 partition boundaries must be aligned to a physical sector as <code>rustBoot</code> erases all flash sectors prior to storing a new firmware image, and swaps the contents of the two partitions, one sector at a time.</p>
<p>To ensure partition-sector alignments are maintained, before proceeding to partition a target system, the following points must be considered:</p>
<ul>
<li><code>BOOT and UPDATE</code> partition must be of the same size.</li>
<li><code>SWAP</code> partition <code>must be larger than the largest sector</code> in either <code>BOOT</code> or <code>UPDATE</code> partition.</li>
</ul>
<p>MCU flash memory is partitioned as follows:</p>
<ul>
<li>rustBoot partition starts at <code>address 0x0</code> in flash memory. It should be at least 32KB in size.</li>
<li><code>BOOT</code> partition starts at a pre-defined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L8"><code>BOOT_PARTITION_ADDRESS</code></a></li>
<li><code>UPDATE</code> partition starts at a pre-defined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L10"><code>UPDATE_PARTITION_ADDRESS</code></a>
<ul>
<li>both partitions must be of the same size, defined by <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L6"><code>PARTITION_SIZE</code></a></li>
</ul>
</li>
<li><code>SWAP</code> partition starts at a predefined address - <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L9"><code>SWAP_PARTITION_ADDRESS</code></a>
<ul>
<li>swap-space size is defined by <a href="https://github.com/nihalpasham/rustBoot/blob/7ea124b2d8f82b85b5500bfdbc038c104eee4452/rustBoot/src/constants.rs#L5"><code>SECTOR_SIZE</code></a> and must be larger than the largest sector in either <code>BOOT</code> or <code>UPDATE</code> partition.</li>
</ul>
</li>
</ul>
<p>BOOT, UPDATE, SWAP addresses and SECTOR_SIZE, PARTITION_SIZE values can be set via command line options or developers <code>constants.rs</code>.</p>
<blockquote>
<p><strong>MCU defaults:</strong></p>
<ul>
<li>By default, public keys used for firmware validation are embedded in <code>rustBoot-firmware</code> during a factory-image-burn. However, rustBoot also offers the option to retrieve them from secure-hardware (ex: crypto-elements).</li>
<li>The <code>BOOT</code> partition is the only partition from which we can boot a firmware image. The firmware image must be linked so that its entry-point is at address <code>256 + BOOT_PARTITION_ADDRESS</code>.</li>
<li><code>BOOT</code> firmware is responsible for downloading a new firmware image via a secure channel and installing it in the <code>UPDATE</code> partition. To trigger an update, the <code>BOOT</code> firmware updates the <code>status byte</code> of the <code>UPDATE</code> partition and performs a reboot. This will allow the bootloader to <code>swap the contents</code> of <code>BOOT</code> partition with that of the <code>UPDATE</code> partition. </li>
</ul>
</blockquote>
<h2 id="linux-system-partitions"><a class="header" href="#linux-system-partitions">Linux system partitions:</a></h2>
<p><a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/linux_partition.svg?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/linux_partition.svg?raw=true" alt="partition" title="Simplified Block Diagram, linux system partition" /></a></p>
<p>To boot into a linux system, rustBoot includes support for the fat32 file-system. </p>
<p>Boot-storage media must contain a fat32 partition </p>
<ul>
<li>of at least 150 MiB to accommodate the bootloader, boot + update fit-images and other vendor-specific boot files and</li>
<li>to add rustBoot support for your board, you can either implement the <code>BlockDevice</code> trait for your board's boot-storage media <code>controller</code> or simply use an existing implementation from the repo.</li>
</ul>
<blockquote>
<p>Note: rustBoot comes with batteries-included. It provides <code>rusty</code> implementations for basic peripherals such as flash, uart, crypto, gpio (out of the box) along with the necessary arch-specific initialization routines.</p>
<ul>
<li>for example: the rustBoot implementation for <code>rpi4</code> includes bare-metal drivers for the on-board emmc controller, gpio and uart peripherals. </li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-boot--update"><a class="header" href="#secure-boot--update">Secure Boot &amp; Update</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing-utilities"><a class="header" href="#signing-utilities">Signing Utilities</a></h1>
<p>As rustBoot supports 2 types of firmware image formats, depending on the underlying device i.e. either an</p>
<ul>
<li><a href="arch/./images.html#mcu-image-format"><code>mcu-image:</code></a> a simple 256-byte firmware image format for microcontrollers or a</li>
<li><a href="arch/./images.html#fit-image-format"><code>fit-image:</code></a> the flattened-image-tree format for systems capable of booting linux.</li>
</ul>
<p>rustBoot <code>rbsigner</code> utility can produce 2 different types signed images. </p>
<h3 id="signed-mcu-image"><a class="header" href="#signed-mcu-image">Signed mcu-image:</a></h3>
<pre><code>[TODO ..]
</code></pre>
<h3 id="signed-fit-image"><a class="header" href="#signed-fit-image">Signed fit-image:</a></h3>
<p>To sign a fit-image, rustBoot's <a href="https://github.com/nihalpasham/rustBoot/tree/main/rbsigner">image signing utility</a> takes 3 inputs </p>
<ul>
<li>an unsigned fit-image in the above format</li>
<li>a raw signing-key or ecdsa private key</li>
<li>the ecdsa curve-type - (nistp256 only for now).</li>
</ul>
<p>Simply run the following command from root directory of the rustBoot project. </p>
<pre><code>cargo run ../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb ../boards/rbSigner/keygen/ecc256.der nistp256
</code></pre>
<p>In the above example:</p>
<ul>
<li><code>../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb</code> is the path to my fit-image </li>
<li><code>../boards/rbSigner/keygen/ecc256.der</code> is the path to my <code>test</code> signing-key</li>
<li><code>nistp256</code> is the type ecdsa curve I'd like to use. Its the only one supported for now.</li>
</ul>
<pre><code>Output: 

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/target/debug/rbsigner ../boards/bootloaders/rpi4/apertis/rpi4-test-apertis.itb ../boards/rbSigner/keygen/ecc256.der nistp256`
signature: ecdsa::Signature&lt;NistP256&gt;([64, 147, 93, 99, 241, 5, 118, 167, 156, 150, 203, 234, 74, 207, 182, 243, 129, 143, 38, 2, 107, 85, 114, 145, 178, 163, 33, 153, 2, 100, 0, 114, 135, 18, 174, 183, 194, 110, 24, 186, 33, 36, 39, 105, 116, 74, 8, 118, 171, 237, 30, 108, 64, 205, 206, 14, 110, 226, 43, 143, 180, 193, 19, 33])
bytes_written: 62202019
</code></pre>
<p>In the above example, the <code>signed fit-image</code> will be stored at the following path - <code>../boards/bootloaders/rpi4/apertis/signed-rpi4-apertis.itb</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build--flash"><a class="header" href="#build--flash">Build &amp; Flash</a></h1>
<p>This section will detail the steps involved in building and flashing <code>rustBoot</code> onto a specific board. More precisely, it will cover the following topics.</p>
<ul>
<li><strong>Partitioning</strong>: 
<ul>
<li>rustBoot offers 2 different partitioning schemes, depending on the target device
<ul>
<li><a href="./arch/partitions.html#micro-controller-partitions">microcontroller partitions</a> </li>
<li><a href="./arch/partitions.html#linux-system-partitions">linux system partitions</a> </li>
</ul>
</li>
</ul>
</li>
<li><strong>Building</strong>: 
<ul>
<li>a rustBoot build usually involves 
<ul>
<li>compiling firmware i.e. boot and update firmware. </li>
<li>signing the compiled firmware. We have 2 different <a href="./arch/signing_utilities.html#signing-utilities">signing schemes</a>, depending on the target device.</li>
<li>compiling rustBoot i.e. the bootloader</li>
</ul>
</li>
</ul>
</li>
<li><strong>Programming</strong>: 
<ul>
<li>After building the required artefacts, the next step is to program the board's non-volatile storage memory.</li>
<li>Again, depending on the target device, we employ different loading/programming strategies.
<ul>
<li><em>mcu</em>(s): typically, rustBoot will use the <a href="https://github.com/knurling-rs/probe-run"><code>probe-run</code></a> utility for programming (and debugging).</li>
<li><em>sbc</em>(s): this will depending the on type of single-board computer. For example: the raspberry-pi uses a sd card for storage and booting.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Verifying</strong>: 
<ul>
<li>To verify that everything works as expected, rustBoot outputs boot-logs. 
<ul>
<li><em>mcu</em>(s): we use a combination of boot-logs and blinking-leds to verify that <code>secure boot and update</code> works as expected. For specifics, please refer to the <code>usage</code> page for the board.</li>
<li><em>sbc</em>(s): rustBoot simply outputs logs to a UART-terminal. For specifics, please refer to <code>usage</code> page for the board.</li>
</ul>
</li>
<li>Among other things, rustBoot logs will indicate <code>image-authentication</code> status. </li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: drivers for peripherals such as flash, uart, gpio etc. are included for each board. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nrf52840"><a class="header" href="#nrf52840"><code>nrf52840</code></a></h1>
<p>The <code>nrf52840</code> example uses a <a href="https://wiki.makerdiary.com/nrf52840-mdk/">maker-diary board</a>. It has a custom led configuration. </p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning"><a class="header" href="#partitioning">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>nrf52840</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;nrf52840&quot;)]
pub const SECTOR_SIZE: usize = 0x1000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const PARTITION_SIZE: usize = 0x28000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x2f000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x57000;
#[cfg(feature = &quot;nrf52840&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x58000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming"><a class="header" href="#compiling-signing-and-programming">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>nrf52840</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-powershell">cargo nrf52840 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites - pyocd, python3 </li>
<li>Owing to the above mentioned dependencies, the command only works in a linux environment or with WSL2 in a windows environment. </li>
</ul>
</blockquote>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-powershell">PS C:\Users\Nil\devspace\rust\projects\rb&gt; cargo xtask build-sign-flash rustBoot nrf52840
   Compiling xtask v0.1.0 (C:\Users\Nil\devspace\rust\projects\rb\xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 1.06s
     Running `target\debug\xtask.exe build-sign-flash rustBoot nrf52840`
$ cargo build --release
   Compiling rand_core v0.6.3
   Compiling nb v1.0.0
   ...
   ...
   Compiling nrf52840_bootfw v0.1.0 (C:\Users\Nil\devspace\rust\projects\rb\boards\test_firmware\nrf52840\boot_fw_blinky_blue)
    Finished release [optimized + debuginfo] target(s) in 46.70s
$ cargo build --release
   Compiling nrf52840_updtfw v0.1.0 (C:\Users\Nil\devspace\rust\projects\rb\boards\test_firmware\nrf52840\updt_fw_blinky_red)
    Finished release [optimized + debuginfo] target(s) in 2.22s
$ cargo build --release
   Compiling defmt-rtt v0.2.0
   Compiling nrf52840 v0.1.0 (C:\Users\Nil\devspace\rust\projects\rb\boards\test_impls\nrf52840)
    Finished release [optimized + debuginfo] target(s) in 5.52s
$ python3 convert2bin.py
$ wsl python3 signer.py
['sign.py', '--ecc256', '--sha256', 'nrf52840_bootfw.bin', 'ecc256.der', '1234']
Update type:          Firmware
Input image:          nrf52840_bootfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         nrf52840_bootfw_v1234_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
Update type:          Firmware
Input image:          nrf52840_updtfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         nrf52840_updtfw_v1235_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
$ pyocd erase -t nrf52 --mass-erase
0001530:INFO:eraser:Successfully erased.
$ pyocd flash -t nrf52840 --base-address 0x2f000 nrf52840_bootfw_v1234_signed.bin
[====================] 100%
0001848:INFO:loader:Erased 4096 bytes (1 sector), programmed 4096 bytes (1 page), skipped 0 bytes (0 pages) at 4.84 kB/s
$ pyocd flash -t nrf52840 --base-address 0x56ffc trailer_magic.bin
[====================] 100%
0002045:INFO:loader:Erased 4096 bytes (1 sector), programmed 4096 bytes (1 page), skipped 0 bytes (0 pages) at 4.23 kB/s
$ pyocd flash -t nrf52840 --base-address 0x58000 nrf52840_updtfw_v1235_signed.bin
[====================] 100%
[====================] 100%
0001983:INFO:loader:Erased 4096 bytes (1 sector), programmed 4096 bytes (1 page), skipped 0 bytes (0 pages) at 4.22 kB/s
    Finished release [optimized + debuginfo] target(s) in 0.15s
    Flashing C:\Users\Nil\devspace\rust\projects\rb\boards\target\thumbv7em-none-eabihf\release\nrf52840
     Erasing sectors ✔ [00:00:01] [############################################################################] 44.00KiB/44.00KiB @ 24.39KiB/s (eta 0s )
 Programming pages   ✔ [00:00:03] [############################################################################] 44.00KiB/44.00KiB @  5.43KiB/s (eta 0s )
    Finished in 4.995s
PS C:\Users\Nil\devspace\rust\projects\rb&gt;
</code></pre>
<h2 id="verifying"><a class="header" href="#verifying">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-4"><a class="header" href="#raspberry-pi-4"><code>raspberry-pi 4</code></a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents"><code>Table of contents:</code></a></h2>
<ul>
<li>  <a href="usage/./rpi4.html#---raspberry-pi-4-boot-sequence"><code>raspberry-pi 4 boot-sequence:</code></a>   🥧 </li>
<li>  <a href="usage/./rpi4.html#---rustboot-execution-sequence"><code>rustBoot execution-sequence:</code></a>   🦀 </li>
<li>  <a href="usage/./rpi4.html#---booting-from-an-sd-card"><code>Booting from an SD card:</code></a>   💾</li>
<li>  <a href="usage/./rpi4.html#---compiling-rustboot"><code>Compiling rustBoot:</code></a>   ⌛</li>
<li>  <a href="usage/./rpi4.html#---adding-a-root-file-system"><code>Adding a root file system:</code></a>   💼</li>
<li>  <a href="usage/./rpi4.html#---uart-communication"><code>UART communication:</code></a>   🚌</li>
<li>  <a href="usage/./rpi4.html#---power-on-and-test"><code>Power-on and test:</code></a>   🧪</li>
</ul>
<h3 id="---raspberry-pi-4-boot-sequence"><a class="header" href="#---raspberry-pi-4-boot-sequence">🥧   raspberry-pi 4 boot-sequence:</a></h3>
<p>rpi4 has an unconventional boot process</p>
<ul>
<li>Upon initial power-on, the <code>bcm2711</code> SoC (CPU is offline but GPU is powered on) executes from the onboard bootROM i.e. <code>1st stage bootloader</code> </li>
</ul>
<blockquote>
<p>Note: the GPU contains a tiny risc core that executes the <code>bootROM</code>. </p>
</blockquote>
<ul>
<li><code>bootROM</code> checks an onboard SPI-EEPROM for a 2nd stage bootloader</li>
<li>This <code>2nd stage bootloader</code> is loaded into the GPU's L2 cache for the GPU to execute. 
<ul>
<li>It initializes system clocks and SDRAM</li>
<li>loads GPU firmware (start4.elf) into RAM</li>
</ul>
</li>
<li>the <code>GPU firmware</code> performs RAM allocations i.e. 
<ul>
<li>RAM is shared between CPU and GPU </li>
<li>enables BCM7211 CPU.</li>
<li>loads <code>rustBoot-bootloader</code> from the SD card into CPU-assigned RAM and passes control of the ARMv8 core to rustBoot</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: At this point, rustBoot has complete control over the CPU. </p>
</blockquote>
<h3 id="---rustboot-execution-sequence"><a class="header" href="#---rustboot-execution-sequence">🦀   rustBoot execution-sequence:</a></h3>
<ul>
<li>By default, rpi4 will always start executing in EL2. Since we are booting a traditional Kernel (i.e. linux), we have to transition into the more appropriate EL1.</li>
</ul>
<blockquote>
<p>Note: EL1 and EL2 are abbreviations for ARMv8-A exception levels</p>
</blockquote>
<p>So, rustBoot checks the following</p>
<ul>
<li>is the core executing in <code>EL2</code>? </li>
<li>are we executing on the <code>boot-core</code> i.e. is it core 0? </li>
<li>if the answer to any of the above questions is <code>no</code>, then we park the core i.e. go into an infinite wait state.</li>
<li>If yes, then we initialize <code>DRAM</code>, <code>zero out bss</code>, transition to EL1 and finally jump to an early initialization routine called kernel_init.</li>
<li><code>kernel_init</code> is an early initialization routine. It takes care of the following - 
<ul>
<li>enables exception handling</li>
<li>enables the MMU along with instruction + data caching</li>
<li>initializes a small set of peripheral drivers i.e EMMC controller, UART, GPIO</li>
<li>and passes control to the core bootloader routine called kernel_main.</li>
</ul>
</li>
<li><code>kernel_main</code> takes care of loading, verifying and booting fit-images.
<ul>
<li>it uses rustBoot's (fat32) file-system to retrieve the first partition (or volume). </li>
</ul>
<blockquote>
<p>Note:  rustBoot does not support GUID Partition Table disks.</p>
</blockquote>
<ul>
<li>If the first volume is a <code>valid fat32</code> partition, it loads the supplied fit-image into RAM and attempts to verify its signature using the ecdsa algorithm.</li>
<li>If the fit-image is authentic i.e. the signature check passes, it relocates the following components to an appropriate location in memory. 
<ul>
<li><code>linux kernel</code></li>
<li><code>fdt or dtb</code></li>
<li><code>ramdisk or initramfs</code></li>
</ul>
</li>
<li>additionally, it will patch the dtb with any supplied (boot-time) kernel command-line arguments. </li>
</ul>
<blockquote>
<p>Note: kernel cmd-line arguments are set at package-build time i.e. when building the fit-image and cannot be interactively set at run time.</p>
</blockquote>
<ul>
<li>Finally, it disables the MMU and boots the linux kernel by jumping to its (relocated) entry point.</li>
</ul>
</li>
</ul>
<h3 id="---booting-from-an-sd-card"><a class="header" href="#---booting-from-an-sd-card">💾   Booting from an SD card:</a></h3>
<p>Raspberry Pi computers use a micro SD card to store a bootable image.</p>
<p><em>SD card preparation:</em> </p>
<ul>
<li>make 2 partitions 
<ul>
<li>the first one must be a <code>fat32</code> partition named <code>firmware</code>. The <code>fat</code> partition needs to be (at-least) 150MB(s). But to keep things simple, you can use a 256MB partition.</li>
<li>the second one can be <code>ext2/3/4</code> partition. This is used to host the root file system. </li>
</ul>
</li>
</ul>
<p><em>FAT32 partition contents:</em></p>
<ul>
<li>Create a file named <code>config.txt</code> with the following contents in the fat partition.</li>
</ul>
<pre><code>    arm_64bit=1
    enable_uart=1
    init_uart_clock=4000000
    kernel=rustBoot.bin
</code></pre>
<ul>
<li>Copy the following files from the Raspberry Pi firmware repo onto the fat partition:
<ul>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/fixup4.dat">fixup4.dat</a></li>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/start4.elf">start4.elf</a></li>
<li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/bcm2711-rpi-4-b.dtb">bcm2711-rpi-4-b.dtb</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: Should it not work on your rpi4, try renaming start4.elf to start.elf (without the 4) on the SD card.</p>
</blockquote>
<h3 id="---compiling-rustboot"><a class="header" href="#---compiling-rustboot">⌛   <code>Compiling rustBoot:</code></a></h3>
<p>You must have rust installed. You can install rust by following the installation instructions <a href="https://www.rust-lang.org/tools/install">here</a>. After installing rust, you'll need to switch to rust's <code>nightly</code> toolchain and add the <code>aarch64</code> compilation-target. This will allow us to compile code for the rpi4 </p>
<pre><code class="language-powershell">rustup default nightly
rustup target add aarch64-unknown-none-softfloat
</code></pre>
<p>Additionally you'll need a few binary utilities to extract the bootloader as a <code>.bin</code> file. They can be installed via the following commands.</p>
<pre><code class="language-powershell">cargo install cargo-binutils
rustup component add llvm-tools-preview
</code></pre>
<p>To verify that you have the pre-requisites installed correctly, run the following command</p>
<pre><code class="language-powershell">rustup show
</code></pre>
<p>In my case, <code>rustup show</code> returns the following output. </p>
<pre><code class="language-powershell">rustup show
Default host: aarch64-apple-darwin
rustup home:  /Users/nihal.pasham/.rustup

installed toolchains
--------------------

stable-aarch64-apple-darwin
nightly-aarch64-apple-darwin (default)

installed targets for active toolchain
--------------------------------------

aarch64-apple-darwin
aarch64-unknown-none-softfloat
thumbv7em-none-eabihf

active toolchain
----------------

nightly-aarch64-apple-darwin (default)
rustc 1.63.0-nightly (ee160f2f5 2022-05-23)
</code></pre>
<p>You should be able to see <code>aarch64-unknown-none-softfloat</code> as one of the installed targets. To compile the rustBoot-bootloader, simply clone the <a href="https://github.com/nihalpasham/rustBoot"><code>rustBoot repo</code></a> and run the following command</p>
<pre><code class="language-powershell">cargo rpi4 build rustBoot-only
</code></pre>
<p>The above command should output the following (output will be longer when compiling for the first time) logs, produce an executable bootloader named <code>rustBoot.bin</code> and store it in the following path <code>./rustBoot/boards/bootloaders/rpi4</code></p>
<pre><code class="language-powershell">Output:
   Compiling xtask v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `target/debug/xtask rpi4 build rustBoot-only`
$ cargo build --release
   Compiling rustBoot v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/rustBoot)
   Compiling rustBoot-hal v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/hal)
   Compiling rpi4 v0.1.0 (/Users/nihal.pasham/devspace/rust/projects/prod/rustBoot/boards/bootloaders/rpi4)
    Finished release [optimized] target(s) in 4.77s
$ rust-objcopy --strip-all -O binary ../../target/aarch64-unknown-none-softfloat/release/kernel rustBoot.bin
</code></pre>
<blockquote>
<p>If you run into any linker issues during the compilation process in a windows environment, please ensure you have C++ build tools installed on your machine. You can download and install the visual studio's build tools from the <a href="https://docs.microsoft.com/en-us/windows/dev-environment/rust/setup">microsoft website</a>.</p>
</blockquote>
<p>After compiling rustBoot, copy <code>rustBoot.bin</code> file onto the sd card's fat32 partition.</p>
<p>The last step in preparing a bootable SD card is to copy the rustBoot fit-image that you'd like to boot onto the sd card's fat32 partition.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>to build a rustBoot fit-image, you can follow <a href="usage/../arch/images.html#building-a-rustboot-compliant-fit-image">these instructions</a> and</li>
<li>to sign a fit-image, you can follow <a href="usage/../arch/images.html#signing-fit-images">these instructions</a>. </li>
</ul>
</blockquote>
<p>Finally, once you've added the above mentioned files to your sd card. The fat32 partition should contain the following files: </p>
<ul>
<li>  config.txt</li>
<li>  fixup4.dat</li>
<li>  start4.elf</li>
<li>  bcm2711-rpi-4-b.dtb</li>
<li>  rustBoot.bin</li>
<li>  signed-example-image.itb</li>
</ul>
<h3 id="---adding-a-root-file-system"><a class="header" href="#---adding-a-root-file-system">💼   Adding a root file system:</a></h3>
<p>There are many ways to add a root file-system to the second ext2/3/4 partition. One way is to copy a root file system to an empty ext2/3/4 drive: </p>
<ul>
<li>Maintainers of a linux distribution provide pre-built OS images. These images usually contain several partitions such as - 
<ul>
<li><code>boot:</code> contains the bootloader, kernel, dtb, ramdisk and other stuff</li>
<li><code>system:</code> contains the root file system </li>
<li><code>others:</code> may contain other partitions for things such as storage etc.</li>
</ul>
</li>
<li>simply download an OS image or a pre-built linux distribution from the maintainers website.
<ul>
<li>in this example, I'll be using the <a href="https://www.apertis.org/download/"><code>apertis</code></a> distribution.</li>
</ul>
</li>
<li>it’s usually in a compressed (zImage) format, decompress it using a tool like unarchiver to get a disk image.</li>
<li>use <code>partx --show</code> to list all partitions</li>
</ul>
<pre><code class="language-powershell">$ partx --show __linux_image_filepath__
NR  START     END SECTORS SIZE NAME UUID
 1   8192  532479  524288 256M      9730496b-01
 2 532480 3661823 3129344 1.5G      9730496b-02
</code></pre>
<ul>
<li>in the above example, partition 2 with a size of 1.5G contains the root file system. It's usually named <code>system</code>.</li>
<li>calculate the offset to the <code>system</code> volume/partition. You can do this with the <code>bc</code> command. </li>
</ul>
<blockquote>
<p><code>512</code> is the sector-size. We multiply sector-size with the sector offset to get the actual starting (byte) location of <code>system</code>.</p>
</blockquote>
<pre><code class="language-powershell">$ bc
bc 1.07.1
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
&gt; 532480 * 512
&gt; 272629760
&gt; quit
</code></pre>
<ul>
<li>mount the partition as an <code>ext4 filesystem</code> </li>
</ul>
<pre><code>$ sudo mkdir /mnt/other
$ sudo mount -v -o offset=272629760 -t ext4 /_path_to_file_image/__filename__.img /mnt/other
mount: /dev/loop0 mounted on /mnt/other.

Check mounted image

$ ls /mnt/other
</code></pre>
<ul>
<li>copy all of (system partition's) contents to sd card's ext2/3/4 partition using the <code>cp</code> command. </li>
</ul>
<blockquote>
<p>Note:</p>
<ul>
<li>this method only works on linux or macOS and does not work on WSL2.</li>
<li>all symbolic links need to be copied. If required you can create symbolic links using <code>ln</code> command. Here' an example that creates a symbolic link called <code>sbin</code> to <code>usr/bin</code> </li>
</ul>
<pre><code class="language-powershell">ln -s usr/sbin sbin 
</code></pre>
</blockquote>
<h3 id="---uart-communication"><a class="header" href="#---uart-communication">🚌   UART communication:</a></h3>
<p>rustBoot will output boot-logs via the raspberry-pi 4's UART interface. These logs can be sent to a host computer (i.e. laptop/desktop).</p>
<p>We'll need extra hardware for this:</p>
<ul>
<li><strong>a usb-to-serial ttl converter:</strong> is a tiny piece of hardware that allows us to send serial data from the rpi4's uart interface to the host
<ul>
<li>You can find USB-to-serial cables that should work right away at <a href="https://www.amazon.de/dp/B0757FQ5CX/ref=cm_sw_r_tw_dp_U_x_ozGRDbVTJAG4Q">[1]</a> <a href="https://www.adafruit.com/product/954">[2]</a>, but many others will work too. Ideally, your cable is based on the CP2102 chip.</li>
<li>You connect it to GND and GPIO pins 14/15 as shown below.</li>
</ul>
</li>
</ul>
<p>Connect the USB-serial converter to your host computer as shown in the wiring diagram
<a href="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/USB-serial.png?raw=true"><img src="https://github.com/imrank03/rustBoot-book-diagrams/blob/main/USB-serial.png?raw=true" alt="wiring diagram" title="USB-Serial UART connection" /></a>.</p>
<ul>
<li>make sure that you DO NOT connect the power pin of the USB serial. Only RX/TX and GND.</li>
<li>connect the rpi4 to the (USB) power cable and observe the output:</li>
</ul>
<p><strong>Serial console:</strong>
To view rpi4's output on a host machine, you'll need a tool/app/console that handles sending and receiving of serial data. There are a number of ways to interact with a serial console. I'll be using </p>
<ul>
<li><code>minicom</code> on linux</li>
<li><code>screen</code> on the mac</li>
<li><code>terminal-s</code> on windows</li>
</ul>
<blockquote>
<p>❗ NOTE: 
Depending on your host operating system, the device name might differ. For example, on macOS, it might be something like /dev/tty.usbserial-0001. In this case, please give the name explicitly:</p>
</blockquote>
<ul>
<li><strong>Using minicom:</strong>
<ul>
<li>install minicom with <code>sudo apt-get install minicom</code>, so you can emulate a terminal connected over serial.</li>
<li>and run </li>
</ul>
<pre><code class="language-powershell">minicom -b 115200 -D /dev/tty.usbserial-0001
</code></pre>
<ul>
<li>boot the Pi.</li>
<li>within a few seconds, you should see data in your session.</li>
</ul>
</li>
<li><strong>Using screen:</strong>
<ul>
<li>on a mac, run </li>
</ul>
<pre><code class="language-powershell">screen /dev/tty.usbserial-0001 115200
</code></pre>
<ul>
<li>boot the Pi.</li>
<li>within a few seconds, you should see data in your session.</li>
</ul>
</li>
<li><strong>Using terminal-s:</strong>
<ul>
<li>on a windows machine, install terminal-s (a python-based serial terminal) with <code>pip install terminal-s</code></li>
<li>and run </li>
</ul>
<pre><code class="language-powershell">terminal-s
</code></pre>
<ul>
<li>no need to provide a baud-rate. It will auto-detect the port and baud-rate (assuming its lower than 115200).</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: </p>
<ul>
<li>To exit the screen session, press Ctrl-A, then Ctrl-K, and confirm you want to exit when using minicom or screen</li>
<li>To exit terminal-s, press Ctrl-]</li>
</ul>
</blockquote>
<h3 id="---power-on-and-test"><a class="header" href="#---power-on-and-test">🧪   Power-on and test:</a></h3>
<p>Now that you have a fully bootable SD card containing</p>
<ul>
<li>a <code>fat32 formatted</code> boot partition populated with the relevant boot files and</li>
<li>a <code>ext2/3/4 formatted</code> root-file-system</li>
</ul>
<p>and have your uart-usb interface set-up, you are now ready to flip the switch i.e. </p>
<ul>
<li>insert the sd card into the pi's sd slot and</li>
<li>supply power to your pi. </li>
</ul>
<p>Your serial console should now start <a href="https://github.com/nihalpasham/rustBoot/blob/main/boards/bootloaders/rpi4/debug.md">receiving boot-logs from the rpi4</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f411"><a class="header" href="#stm32f411"><code>stm32f411</code></a></h1>
<p>The <code>stm32f411</code> example uses a <a href="https://www.st.com/en/evaluation-tools/32f411ediscovery.html">STM32F411EDISCOVERY BOARD</a>.The board has four LEDs of which two LEDs are used in this example. </p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-1"><a class="header" href="#partitioning-1">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f411</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f411&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const PARTITION_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x08060000;
#[cfg(feature = &quot;stm32f411&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08040000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-1"><a class="header" href="#compiling-signing-and-programming-1">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f411</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-MAC">cargo stm32f411 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
<li>cargo install probe-rs-cli </li>
<li>cargo install cargo-flash </li>
</ul>
</blockquote>
<p>Here's the command line output that should be produced.</p>
<pre><code>yashwanthsingh@Yashwanths-MBP rustBoot % cargo stm32f411 build-sign-flash rustBoot
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running `target/debug/xtask stm32f411 build-sign-flash rustBoot`
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/firmware/stm32f411/boot_fw_blinky_green/.cargo/config.toml`
   ..
   ..
   Compiling rustBoot v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/rustBoot)
   Compiling stm32f4xx-hal v0.10.1
   Compiling rustBoot-hal v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/update)
   Compiling boot_fw_blinky_green v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/firmware/stm32f411/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 18.33s
$ cargo build --release
warning: unused config key `build.runner` in `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/firmware/stm32f411/updt_fw_blinky_red/.cargo/config.toml`
   Compiling update_fw_blinky_red v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/firmware/stm32f411/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 0.87s
$ cargo build --release
   ..
   ..
   Compiling rustBoot v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/rustBoot)
   Compiling stm32f4xx-hal v0.10.1
   Compiling rustBoot-hal v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/update)
   Compiling stm32f411 v0.1.0 (/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/bootloaders/stm32f411)
    Finished release [optimized] target(s) in 16.40s
$ rust-objcopy ../../boards/target/thumbv7em-none-eabihf/release/boot_fw_blinky_green -O binary stm32f411_bootfw.bin
$ rust-objcopy ../../boards/target/thumbv7em-none-eabihf/release/update_fw_blinky_red -O binary stm32f411_updtfw.bin
$ cargo run --example SignBootImage stm32f411_bootfw.bin
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/target/debug/examples/SignBootImage stm32f411_bootfw.bin`
$ cargo run --example SignUpdateImage stm32f411_updtfw.bin
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `/Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/target/debug/examples/SignUpdateImage stm32f411_updtfw.bin`
$ probe-rs-cli erase --chip stm32f411vetx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip stm32f411vetx stm32f411_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:01] [#################################] 128.00KiB/128.00KiB @ 65.20KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [###################################]  5.00KiB/ 5.00KiB @  1.08KiB/s (eta 0s )
    Finished in 2.135s
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f411vetx stm32f411_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [#################################] 128.00KiB/128.00KiB @ 65.50KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [###################################]  5.00KiB/ 5.00KiB @  1.08KiB/s (eta 0s )
    Finished in 2.121s
$ cargo flash --chip stm32f411vetx --release
    Finished release [optimized] target(s) in 0.07s
    Flashing /Users/yashwanthsingh/Yash/Projects/git_rustBoot_yash/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f411
     Erasing sectors ✔ [00:00:01] [###################################] 48.00KiB/48.00KiB @ 40.80KiB/s (eta 0s )
 Programming pages   ✔ [00:00:01] [###################################] 43.00KiB/43.00KiB @ 16.79KiB/s (eta 0s )
    Finished in 2.319s
yashwanthsingh@Yashwanths-MBP rustBoot % 
</code></pre>
<h2 id="verifying-1"><a class="header" href="#verifying-1">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f446-nucleo"><a class="header" href="#stm32f446-nucleo"><code>stm32f446 Nucleo</code></a></h1>
<p>The <code>stm32f446</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f446re.html">STM32F446 Nucleo Board</a>. The board has 1 user LED which will be blinking at different frequencies depending on whether we're executing boot-firmware or update-firmware.</p>
<blockquote>
<p>Note </p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-2"><a class="header" href="#partitioning-2">Partitioning</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f446</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f446&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const PARTITION_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x08060000;
#[cfg(feature = &quot;stm32f446&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08040000;
<span class="boring">}
</span></code></pre></pre>
<p><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</p>
<ul>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-2"><a class="header" href="#compiling-signing-and-programming-2">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f446 Nucleo's</code> on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-MAC">cargo stm32f446 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash 
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code>anand@anand-VirtualBox:~/Desktop/dev_space/Prod/rustBoot$ cargo stm32f446 build pkgs-for
   Compiling der v0.5.1
   Compiling typenum v1.15.0
   ..
   ..
   Compiling xtask v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 8.51s
     Running `target/debug/xtask stm32f446 build pkgs-for`
$ cargo build --release
   Compiling subtle v2.4.1
   Compiling rand_core v0.6.3
   ..
   ..
   Compiling stm32f446_boot_fw v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot/boards/firmware/stm32f446/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 30.43s
$ cargo build --release
   Compiling stm32f446_updt_fw v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot/boards/firmware/stm32f446/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 1.10s
$ cargo build --release
   Compiling subtle v2.4.1
   Compiling rand_core v0.6.3
   ..
   ..
   Compiling rustBoot-update v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot/boards/update)
   Compiling stm32f446 v0.1.0 (/home/anand/Desktop/dev_space/Prod/rustBoot/boards/bootloaders/stm32f446)
    Finished release [optimized] target(s) in 30.34s

</code></pre>
<h2 id="verifying-2"><a class="header" href="#verifying-2">Verifying:</a></h2>
<p><code>user led</code> is used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>user led</code> for a few seconds, at an interval of <code>0.5 seconds</code>.
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>user led</code> at an interval of <code>1 second</code>. </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>user led</code> at an interval of <code>1 second</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32h723"><a class="header" href="#stm32h723"><code>stm32h723</code></a></h1>
<p>The <code>stm32h723</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-h723zg.html">Nucleo-h723zg board</a>. The board has three <code>LEDs</code> of which two <code>LEDs</code> are used in this example.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-3"><a class="header" href="#partitioning-3">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32h723</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory.</p>
<blockquote>
<p>Note:</p>
<ul>
<li><a href="https://www.st.com/resource/en/application_note/an5342-error-correction-code-ecc-management-for-internal-memories-protection-on-stm32h7-series-stmicroelectronics.pdf">Error correction code</a> memory is a type of flash memory data storage that uses error correction code to detect and correct n-bit data corruption that occurs in memory.</li>
<li>Since the <strong>STM32H7</strong> series devices have a 10-bit <code>ECC</code> function, it is not possible to write partition status/sector flags more than once, so use a bigger <code>PARTITION_SIZE</code>. The last <code>128KB</code> sector in each partition will be reserved for bootloader flags or partition status.</li>
</ul>
</blockquote>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32h723&quot;)]
pub const SECTOR_SIZE: usize = 0x20000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const PARTITION_SIZE: usize = 0x40000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08020000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x080A0000;
#[cfg(feature = &quot;stm32h723&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08060000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-3"><a class="header" href="#compiling-signing-and-programming-3">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32h723</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32h723 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites - probe-rs-cli, python3 </li>
<li>Owing to the above mentioned dependencies, the command only works in a linux environment or with WSL2 in a windows environment. </li>
</ul>
</blockquote>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-Terminal">imran@ubuntu:~/Desktop/rustBoot$ cargo stm32h723 build-sign-flash rustBoot
Compiling typenum v1.15.0
Compiling version_check v0.9.4
..
..
Compiling rustBoot v0.1.0 (/home/imran/Desktop/rustBoot/rustBoot)
Compiling xtask v0.1.0 (/home/imran/Desktop/rustBoot/xtask)
Finished dev [unoptimized + debuginfo] target(s) in 7.43s
Running target/debug/xtask stm32h723 build-sign-flash rustBoot
$ cargo build --release
Compiling version_check v0.9.4
Compiling typenum v1.15.0
..
..
Compiling rustBoot-hal v0.1.0 (/home/imran/Desktop/rustBoot/boards/hal)
Compiling rustBoot-update v0.1.0 (/home/imran/Desktop/rustBoot/boards/update)
Finished release [optimized] target(s) in 26.19s
$ cargo build --release
Compiling stm32h723_updtfw v0.1.0 (/home/imran/Desktop/rustBoot/boards/firmware/stm32h723/updt_fw_blinky_red)
Finished release [optimized] target(s) in 1.03s
$ cargo build --release
Compiling stm32h723 v0.1.0 (/home/imran/Desktop/rustBoot/boards/bootloaders/stm32h723)
Finished release [optimized] target(s) in 1.50s
$ python3 convert2bin.py
$ python3 signer.py
['sign.py', '--ecc256', '--sha256', 'stm32h723_bootfw.bin', 'ecc256.der', '1234']
Update type:          Firmware
Input image:          stm32h723_bootfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32h723_bootfw_v1234_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
['sign.py', '--ecc256', '--sha256', 'stm32h723_updtfw.bin', 'ecc256.der', '1235']
Update type:          Firmware
Input image:          stm32h723_updtfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32h723_updtfw_v1235_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
$ probe-rs-cli erase --chip stm32h723zgtx
$ probe-rs-cli download --format Bin --base-address 0x8020000 --chip stm32h723zgtx stm32h723_bootfw_v1234_signed.bin
Erasing sectors ✔ [00:00:00] [##################################################################################################]  3.00KiB/ 3.00KiB @  7.30KiB/s (eta 0s )
Programming pages   ✔ [00:00:00] [##################################################################################################]  3.00KiB/ 3.00KiB @  3.85KiB/s (eta 0s )
Finished in 0.611s
$ probe-rs-cli download --format Bin --base-address 0x8060000 --chip stm32h723zgtx stm32h723_updtfw_v1235_signed.bin
Erasing sectors ✔ [00:00:00] [##################################################################################################]  3.00KiB/ 3.00KiB @  7.17KiB/s (eta 0s )
Programming pages   ✔ [00:00:00] [##################################################################################################]  3.00KiB/ 3.00KiB @  3.77KiB/s (eta 0s )
Finished in 0.613s
$ cargo flash --chip stm32h723zgtx --release
Finished release [optimized] target(s) in 0.04s
Flashing /home/imran/Desktop/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32h723
Erasing sectors ✔ [00:00:02] [##################################################################################################] 47.00KiB/47.00KiB @ 17.60KiB/s (eta 0s )
Programming pages   ✔ [00:00:03] [##################################################################################################] 47.00KiB/47.00KiB @  7.60KiB/s (eta 0s )
Finished in 5.773s
</code></pre>
<h2 id="verifying-3"><a class="header" href="#verifying-3">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f746"><a class="header" href="#stm32f746"><code>stm32f746</code></a></h1>
<p>The <code>stm32f746</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f746zg.html">Nucleo-f746zg board</a>. The board has three <code>LEDs</code> of which two <code>LEDs</code> are used in this example.</p>
<blockquote>
<p>Note:</p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-4"><a class="header" href="#partitioning-4">Partitioning:</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f746</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory.</p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f746&quot;)]
pub const SECTOR_SIZE: usize = 0x40000; 
#[cfg(feature = &quot;stm32f746&quot;)]
pub const PARTITION_SIZE: usize = 0x40000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x08040000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x080C0000;
#[cfg(feature = &quot;stm32f746&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x08080000;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0</code>.</li>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-4"><a class="header" href="#compiling-signing-and-programming-4">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f746</code>'s on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-Terminal">cargo stm32f746 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites - probe-rs-cli, python3 </li>
<li>Owing to the above mentioned dependencies, the command only works in a linux environment or with WSL2 in a windows environment. </li>
</ul>
</blockquote>
<p>Here's the command line output that should be produced.</p>
<pre><code class="language-Terminal">udayakumar@udayakumar-VirtualBox:~/devspace/rustBoot$ cargo stm32f746 build-sign-flash rustBoot
   Compiling xtask v0.1.0 (/home/udayakumar/devspace/rustBoot/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/xtask stm32f746 build-sign-flash rustBoot`
$ cargo build --release
   Compiling rand_core v0.6.3
   Compiling nb v1.0.0
   Compiling subtle v2.4.1
   Compiling const-oid v0.7.1
   Compiling vcell v0.1.3
   ...
   Compiling rustBoot v0.1.0 (/home/udayakumar/devspace/rustBoot/rustBoot)
   Compiling stm32f7xx-hal v0.7.0
   Compiling rustBoot-hal v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/hal)
   Compiling rustBoot-update v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/update)
   Compiling stm32f746_bootfw v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/firmware/stm32f746/boot_fw_blinky_green)
    Finished release [optimized] target(s) in 23.39s
$ cargo build --release
   Compiling stm32f746_updtfw v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/firmware/stm32f746/updt_fw_blinky_red)
    Finished release [optimized] target(s) in 0.65s
$ cargo build --release
   Compiling stm32f746 v0.1.0 (/home/udayakumar/devspace/rustBoot/boards/bootloaders/stm32f746)
    Finished release [optimized] target(s) in 1.26s
$ python3 convert2bin.py
$ python3 signer.py
['sign.py', '--ecc256', '--sha256', 'stm32f411_updtfw.bin', 'ecc256.der', '1235']
Update type:          Firmware
Input image:          stm32f411_updtfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f411_updtfw_v1235_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
['sign.py', '--ecc256', '--sha256', 'stm32f746_updtfw.bin', 'ecc256.der', '1235']
Update type:          Firmware
Input image:          stm32f746_updtfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f746_updtfw_v1235_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
['sign.py', '--ecc256', '--sha256', 'stm32f746_bootfw.bin', 'ecc256.der', '1234']
Update type:          Firmware
Input image:          stm32f746_bootfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f746_bootfw_v1234_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
['sign.py', '--ecc256', '--sha256', 'stm32f411_bootfw.bin', 'ecc256.der', '1234']
Update type:          Firmware
Input image:          stm32f411_bootfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f411_bootfw_v1234_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
$ probe-rs-cli erase --chip stm32f746zgtx
$ probe-rs-cli download --format Bin --base-address 0x8040000 --chip stm32f746zgtx stm32f746_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:03] [################################################################################################################] 256.00KiB/256.00KiB @ 69.45KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [##################################################################################################################]  3.00KiB/ 3.00KiB @     332B/s (eta 0s )
    Finished in 6.597s
$ probe-rs-cli download --format Bin --base-address 0x8080000 --chip stm32f746zgtx stm32f746_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:03] [################################################################################################################] 256.00KiB/256.00KiB @ 69.65KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [##################################################################################################################]  3.00KiB/ 3.00KiB @     332B/s (eta 0s )
    Finished in 6.586s
$ cargo flash --chip stm32f746zgtx --release
    Finished release [optimized] target(s) in 0.06s

    Flashing /home/udayakumar/devspace/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f746
     Erasing sectors ✔ [00:00:02] [##################################################################################################################] 64.00KiB/64.00KiB @ 21.29KiB/s (eta 0s )
 Programming pages   ✔ [00:00:21] [##################################################################################################################] 43.00KiB/43.00KiB @  1.80KiB/s (eta 0s )
    Finished in 24.035s
udayakumar@udayakumar-VirtualBox:~/devspace/rustBoot$ 
</code></pre>
<h2 id="verifying-4"><a class="header" href="#verifying-4">Verifying:</a></h2>
<p><code>blinky leds</code> are used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>green-led</code> for a few seconds, 
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware
<ul>
<li>it will attempt to blink a <code>red-led</code> </li>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>red-led</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32f334"><a class="header" href="#stm32f334"><code>stm32f334</code></a></h1>
<p>The <code>stm32f334</code> example uses a <a href="https://www.st.com/en/evaluation-tools/nucleo-f334r8.html">STM32F334 Nucleo-64 Board</a>. The board has 1 user LED which will be blinking at different frequencies depending on whether we're executing boot-firmware or update-firmware.</p>
<blockquote>
<p>Note </p>
<ul>
<li>If you're using a different version of the board, you'll probably need to edit your firmware's <code>partition-addresses</code> to accommodate for differences. </li>
<li>Just make sure you don't change the names of files or the folder structure, as cargo xtask looks for these file/folder names.</li>
</ul>
</blockquote>
<h2 id="partitioning-5"><a class="header" href="#partitioning-5">Partitioning</a></h2>
<p>The first step in integrating rustBoot is <code>flash-memory partitioning</code> i.e. we divide the <code>stm32f334</code>'s flash-memory into 4 partitions, taking into account the geometry of the flash memory. </p>
<blockquote>
<p>You can read more about <code>mcu</code> partitioning <a href="usage/../arch/partitions.html#micro-controller-partitions">here</a></p>
</blockquote>
<p>In this example, we'll be using the following partitioning scheme. You can locate these constants in the <a href="https://github.com/nihalpasham/rustBoot/blob/main/rustBoot/src/constants.rs">constants module</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;stm32f334&quot;)]
pub const SECTOR_SIZE: usize = 0x1800; 
#[cfg(feature = &quot;stm32f334&quot;)]
pub const PARTITION_SIZE: usize = 0x1800;
#[cfg(feature = &quot;stm32f334&quot;)]
pub const BOOT_PARTITION_ADDRESS: usize = 0x0800b800; //its is of 3 pages starting from this address as the boot firmware is 2.47KiB
#[cfg(feature = &quot;stm32f334&quot;)]
pub const SWAP_PARTITION_ADDRESS: usize = 0x0800e800; //its is of 3 pages starting from this address
#[cfg(feature = &quot;stm32f334&quot;)]
pub const UPDATE_PARTITION_ADDRESS: usize = 0x0800d000; //its is of 3 pages starting from this address as the update firmware is 2.50KiB

&gt; Note: Choose the number of pages based on your boot and update firmware sizes.

<span class="boring">}
</span></code></pre></pre>
<p><strong><code>RUSTBOOT partition:</code></strong> contains the bootloader (its code and data) and a (test) public-key embedded as part of the bootloader image, starts at address <code>0x0800_0000</code>.</p>
<ul>
<li><strong><code>BOOT partition:</code></strong> contains boot firmware, starts at address <code>PARTITION_BOOT_ADDRESS</code>.</li>
<li><strong><code>UPDATE partition:</code></strong> contains update firmware, starts at address <code>UPDATE_PARTITION_ADDRESS</code>. The boot firmware is responsible for downloading and installing the update firmware into this partition via a secure channel.</li>
<li><strong><code>SWAP partition:</code></strong> is the temporary swap space, starts at address <code>SWAP_PARTITION_ADDRESS</code>. </li>
</ul>
<h2 id="compiling-signing-and-programming-5"><a class="header" href="#compiling-signing-and-programming-5">Compiling, Signing and Programming:</a></h2>
<p>Now that we have properly partitioned the <code>stm32f334 Nucleo's</code> on-board flash-memory, the next step is - <code>compiling, signing and programming </code> </p>
<p>We will compile the following </p>
<ul>
<li>bootloader </li>
<li>boot and update firmware</li>
</ul>
<p>sign both pieces of firmware with a (test) <a href="https://github.com/nihalpasham/rustBoot/tree/main/boards/rbSigner/keygen">private-key</a> and finally create valid <a href="usage/../arch/images.html#mcu-image-format"><code>rustBoot mcu-images</code></a> i.e. signed boot and update firmware images.</p>
<p>Compiling, signing and programming can be performed via a single command</p>
<pre><code class="language-MAC">cargo stm32f334 build-sign-flash rustBoot
</code></pre>
<p>This will build, sign and flash all 3 packages (i.e. bootloader + boot-fw + update-fw) onto the board.</p>
<blockquote>
<p>Note: </p>
<ul>
<li>The corresponding public-key is embedded in the bootloader's source.</li>
<li>In order to test this example, you'll have to install a couple of pre-requisites  as it uses probe-run to flash the binary.</li>
</ul>
</blockquote>
<pre><code class="language-powershell">cargo install probe-rs-cli 
cargo install cargo-flash 
</code></pre>
<p>Here's the command line output that should be produced.</p>
<pre><code>sarathk@sarath:~/stm32f/pull_req/rustBoot$ cargo stm32f334 build-sign-flash rustBoot
   Compiling xtask v0.1.0 (/home/sarathk/stm32f/pull_req/rustBoot/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/xtask stm32f334 build-sign-flash rustBoot`
$ cargo build --release
    Finished release [optimized] target(s) in 0.23s
$ cargo build --release
    Finished release [optimized] target(s) in 0.22s
$ cargo build --release
    Finished release [optimized] target(s) in 0.16s
$ python3 convert2bin.py
$ python3 signer.py
['sign.py', '--ecc256', '--sha256', 'stm32f334_updtfw.bin', 'ecc256.der', '1235']
Update type:          Firmware
Input image:          stm32f334_updtfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f334_updtfw_v1235_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
['sign.py', '--ecc256', '--sha256', 'stm32f334_bootfw.bin', 'ecc256.der', '1234']
Update type:          Firmware
Input image:          stm32f334_bootfw.bin
Selected cipher:      ecc256
Public key:           ecc256.der
Output image:         stm32f334_bootfw_v1234_signed.bin
Not Encrypted
Calculating sha256 digest...
Signing the firmware...
Done.
Output image successfully created.
$ probe-rs-cli erase --chip stm32f334r8tx
$ probe-rs-cli download --format Bin --base-address 0x800b800 --chip stm32f334r8tx stm32f334_bootfw_v1234_signed.bin
     Erasing sectors ✔ [00:00:01] [#####################################################################################]  4.00KiB/ 4.00KiB @  1.75KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [#####################################################################################]  3.00KiB/ 3.00KiB @     537B/s (eta 0s )
    Finished in 4.654s
$ probe-rs-cli download --format Bin --base-address 0x800d000 --chip stm32f334r8tx stm32f334_updtfw_v1235_signed.bin
     Erasing sectors ✔ [00:00:01] [#####################################################################################]  4.00KiB/ 4.00KiB @  1.78KiB/s (eta 0s )
 Programming pages   ✔ [00:00:02] [#####################################################################################]  3.00KiB/ 3.00KiB @     542B/s (eta 0s )
    Finished in 4.625s
$ cargo flash --chip stm32f334r8tx --release
    Finished release [optimized] target(s) in 0.22s
    Flashing /home/sarathk/stm32f/pull_req/rustBoot/boards/target/thumbv7em-none-eabihf/release/stm32f334
     Erasing sectors ✔ [00:00:10] [#####################################################################################] 44.00KiB/44.00KiB @  3.92KiB/s (eta 0s )
 Programming pages   ✔ [00:00:21] [#####################################################################################] 43.00KiB/43.00KiB @  1.27KiB/s (eta 0s )
    Finished in 32.288s
sarathk@sarath:~/stm32f/pull_req/rustBoot$ 
</code></pre>
<h2 id="verifying-5"><a class="header" href="#verifying-5">Verifying:</a></h2>
<p><code>user led</code> is used to confirm that rustBoot works as expected. Here's the flow</p>
<ul>
<li>Upon supplying power to the board, rustBoot takes over 
<ul>
<li>validates the firmware image stored in the BOOT partition</li>
<li>verifies the signature attached against a known public key stored in the rustBoot image.</li>
</ul>
</li>
<li>If the signature checks out, rustBoot boots into the bootfw and blinks a <code>user led</code> for a few seconds, at an interval of <code>1 second</code> three times.
<ul>
<li>post which, the boot firmware triggers the update and performs a system reset. </li>
</ul>
</li>
<li>Upon reset, the rustBoot again takes over 
<ul>
<li>validates the firmware image stored in the UPDATE partition </li>
<li>swaps the contents of the BOOT and the UPDATE partitions</li>
<li>marks the new firmware in the BOOT partition as in state STATE_TESTING</li>
<li>boots into the UPDATE'd firmware </li>
</ul>
</li>
<li>Now that execution-control has been transferred to the UPDATE'd firmware 
<ul>
<li>and set a <code>confirmation flag</code> to indicate that the update was successful.</li>
<li>post which, it continuously blinks a <code>user led</code> at an interval of <code>0.25 second</code> continuously.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-coding-guidelines"><a class="header" href="#secure-coding-guidelines">Secure Coding guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-guide"><a class="header" href="#reference-guide">Reference Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improve <code>rustBoot</code>. Big shout-out to them!</p>
<blockquote>
<ol>
<li><a href="https://github.com/imrank03" title="@imrank03"><strong><code>Imran K</code></strong> <img height="13" width="12" src="https://unpkg.com/simple-icons@v7/icons/github.svg" /></a></li>
<li><a href="https://github.com/yashwanthsinghm" title="yashwanthsinghm"><strong><code>Yashwanth Singh M</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/strange21" title="strange21"><strong><code>Anand Gedam</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/UdayakumarHidakal" title="@UdayakumarHidakal"><strong><code>Udayakumar Hidakal</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/sarath3192" title="sarath3192"><strong><code>Bobbili Sarath Kumar</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
</ol>
</blockquote>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
